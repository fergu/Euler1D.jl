var documenterSearchIndex = {"docs":
[{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/#Sod-Shock-Tube","page":"Examples","title":"Sod Shock Tube","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The Sod shock tube is a case involving a rightwards travelling shock wave and a leftwards travelling expansion wave. Its initial condition is given by:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"left(\nbeginaligned\nrho_L \nP_L \nu_L\nendaligned\nright) =\nleft(\nbeginaligned\n10 \n10 \n00\nendaligned\nright)\nleft(\nbeginaligned\nrho_R \nP_R \nu_R\nendaligned\nright) =\nleft(\nbeginaligned\n0125 \n01 \n00\nendaligned\nright)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"where rho, P, and u are the density, pressure, and velocity, the domain is in the range x=01, and the subscripts L and R refer to states to the left and right of an interface initially located at x=05. While an exact solution for this configuration can be found, this example will focus on setting up an Euler1D simulation to simulate the Sod shock tube.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"A simulation is initialized using a set of dictionary key:value pairs describing various aspects of the simulation, including the functions used to describe the initial profiles of density, velocity, pressure, and the ratio of specific heats. A default set of parameters can be obtained using the function [DefaultSimulationParameters()][@ref]:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Euler1D\nsimulation_parameters = DefaultSimulationParameters()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"You may notice that there are several parameters with a value of nothing. These must be supplied before the simulation can be initialized since it is difficult to make reasonable default assumptions. Of particular note are the keys init_density_function, init_velocity_function, init_pressure_function, and init_gamma_function. These refer to functions that describe the inital profiles of density, velocity, pressure, and the ratio of specific heats, respectively. A set of functions to implement the Sod shock tube initial conditions looks like:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"function init_density( x )\n    if ( x < 0.5 )\n        return 1.0\n    else\n        return 0.125\n    end\nend;\n\nfunction init_velocity( x )\n    return 0.0\nend;\n\nfunction init_pressure( x )\n    if ( x < 0.5 )\n        return 1.0\n    else\n        return 0.1\n    end\nend;\n\nfunction init_gamma( x )\n    return 1.4\nend;","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"caution: Caution\nThe x argument in these functions is the location of where a given variable will be stored. Due to the fact that some variables are zone-centered while others are edge-centered, it should not be assumed that x will have the same value in all functions. Additionally, due to how Julia performs vectorized computations, these functions should not assume anything about the order in which they are executed. i.e., that the n-th function call will always have a certain value of x.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The simulation_parameters dictionary can now be modified to describe the desired initial condition. In this case, this would look like:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"simulation_parameters[\"init_density_function\"] = init_density;\nsimulation_parameters[\"init_velocity_function\"] = init_velocity;\nsimulation_parameters[\"init_pressure_function\"] = init_pressure;\nsimulation_parameters[\"init_gamma_function\"] = init_gamma;","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The simulation_parameters dictionary has many other keys that can be modified. See DefaultSimulationParameters() for a list of parameters that can be set.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Once all desired parameters have been set, the simulation can be initialized:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"init_state = InitializeSimulation( simulation_parameters )\nprintln( init_state ) # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The init_state variable is a Simulation type that holds information about the simulation. ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"note: Note\nThe functions that describe the initial conditions are not called until InitializeSimulation() is called, at which time they are called at every point in the domain. For these reasons, it is good to be sure that the functions are not computationally heavy.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"A common time to examine the Sod shock tube solution is t=0.1. The AdvanceToTime() function can be used to advance the simulation to this time:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"end_state = AdvanceToTime( init_state, 0.1; exact=true )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"where 0.1 is the time to advance to and the exact=true keyword tells the simulation to modify the final time step to stop as close as possible to the final time. If exact=false were supplied instead (or if the exact argument was omitted), the simulation would stop as soon as the current time is greater than the specified stopping time, but no modification of the timestep would be made and so the actual stopping time may differ from the specified stopping time. The size of the difference will depend on the timestep size.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"tip: Tip\nThis example wrote out the functions used for initial conditions in full for instructive purposes. However, there is no requirement that the functions be defined in this way. For example, for simple initial conditions, a function could be defined using ternary operators:init_density( x ) = x < 0.5 ? 1.0 : 0.125; # A function that varies in space\ninit_gamma( x ) = 1.4; # A function with a constant valueor even using anonymous functions:simulation_parameters = Dict{String,Any}() # hide\nsimulation_parameters[\"init_density_function\"] = (x) -> x < 0.5 ? 1.0 : 0.125; # A function that varies in space\nsimulation_parameters[\"init_gamma_function\"] = (x) -> 1.4; # A function with a constant valueThere is no requirement or advantage to using one method over any other. These are simply alternative ways of defining a function to describe the initial condition.","category":"page"},{"location":"Examples/#Plotting-Results","page":"Examples","title":"Plotting Results","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This section outlines a few examples of how simulation data can be post-processed to visualize results or perform advanced processing.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"note: Note\nThere are numerous packages in the Julia ecosystem to handle plotting (e.g. Plots.jl, Makie.jl), writing to disk (e.g. CSV.jl, DataFrames.jl, HDF5.jl), and any other data analysis routine that might be desired. The people developing these packages (and others like them) are immensely talented, and one would be well-advised to utilize their hard work if a package with suitable functionality exists.  For this reason, this package actively avoids making assumptions about what a user will want to do with the simulation data after the simulation is complete. This means that there is no built-in functionality to plot simulation data, write it to disk, or perform any other sort of postprocessing. Instead, all simulation outputs are simply elementary Julia types (e.g. Vector{Float64}), and can be manipulated using the usual built-in Julia methods, or by using any suitable package that provides the required functionality. ","category":"page"},{"location":"Examples/#Line-Plot","page":"Examples","title":"Line Plot","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The simplest case of post-processing data is to just plot profiles of the solution state at the final time in the simulation. Fortunately, all necessary fields can be obtained from the Simulation variable in the form of elementary Julia types. For example, to plot the profile of density from the simulation performed in Sod Shock Tube using the Plots.jl library, one can do","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Plots\nplot( end_state.zone_center, end_state.density );\nsavefig( \"sod_density.svg\" ) # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Similar plots can be made for other zone-centered quantities such as internal energy or pressure. ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"tip: Tip\nIf plotting edge-centered quantities such as velocity, the end_state.zone_edge variable should be used for the spatial coordinate.","category":"page"},{"location":"Examples/#X-T-diagrams","page":"Examples","title":"X-T diagrams","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"It is often useful to look at the evolution of the problem solution as a function of space and time rather than at just a single time instant. X-T diagrams are a useful way to perform this visualization. Gathering the data required to generate this type of plot is a little bit more complicated than the previous examples, however.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The simulation can be set up identically to previous examples: ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Euler1D # hide\nsimulation_parameters = DefaultSimulationParameters();\n# We'll define our initialization functions using anonymous functions to keep things short\nsimulation_parameters[\"init_density_function\"] = (x) -> x < 0.5 ? 1.0 : 0.125;\nsimulation_parameters[\"init_velocity_function\"] = (x) -> 0.0;\nsimulation_parameters[\"init_pressure_function\"] = (x) -> x < 0.5 ? 1.0 : 0.1;\nsimulation_parameters[\"init_gamma_function\"] = (x) -> 1.4;\ninit_state = InitializeSimulation( simulation_parameters )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"In order to generate an X-T diagram, we will need to record the simulation state at multiple times in the simulation. To do this, let's define a new function that will be responsible for advancing the simulation through time: ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Interpolations\nusing Plots\n\nfunction run_simulation( init_state::Simulation{T}, end_time::T ) where { T <: AbstractFloat }\n    new_state = deepcopy( init_state ) # We'll need a copy of our initial state to modify inside the while loop\n    # Information about plotting\n    plot_dt = 0.001 # How often to stop and record data\n    next_plot = 0.0 # The next time to stop and record data\n    # Set up some matricies to hold our plotting data\n    plot_times = zeros( 0 ) # The times at which we've recorded data\n    plot_positions = init_state.zone_center # Where to plot the data at in space. We'll use the initial grid\n    plot_J₊ = zeros( 0, init_state.nzones ) # A matrix of the positive Riemann invariant values in every zone in the simulation\n    plot_J₋ = zeros( 0, init_state.nzones ) # A matrix of the negative Riemann invariant values at every zone in the simulation\n    while ( new_state.time.x <= end_time ) # Keep looping until we've reached our end time\n        new_state = AdvanceToTime( new_state, next_plot; exact=true ) # Advance the solution to the next time to record data\n        # Now record data about the simulation state\n        plot_times = vcat( plot_times, new_state.time.x ) # Record our current time, appending it to the plot_times vector\n        # Now compute the Riemann invariants. \n        # For this we'll need to interpolate the velocities to zone centers, which we'll do with a simple average\n        uₘ = 0.5 .* ( new_state.velocity[1:end-1] .+ new_state.velocity[2:end] )\n        # Now compute the Riemann invariants\n        J₊ = uₘ .+ ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Positive Riemann invariant\n        J₋ = uₘ .- ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Negative Riemann invariant\n        # Most contour plot functions assume data is on a cartesian grid \n        # However, because the grid zones in the simulation are moving, we'll need to interpolate the data back onto a cartesian grid.\n        # For simplicity, we will use the initial simulation grid as the grid for plotting\n        # We can use Interpolations.jl for this\n        J₊_interp = interpolate( ( new_state.zone_center, ), J₊, Gridded(Linear()) ) # Set up a linear interpolation of our data\n        J₊_extrap = extrapolate( J₊_interp, Line() ) # Linearly extrapolate if needed.\n        plot_J₊ = vcat( plot_J₊, J₊_extrap( plot_positions )' ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data\n\n        J₋_interp = interpolate( ( new_state.zone_center, ), J₋, Gridded(Linear()) ) # Set up a linear interpolation of our data\n        J₋_extrap = extrapolate( J₋_interp, Line() ) # Linearly extrapolate if needed\n        plot_J₋ = vcat( plot_J₋, J₋_extrap( plot_positions )' ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data\n        next_plot = next_plot + plot_dt\n    end\n    # Now that the simulation is done, we can save our plot\n    # First compute the minimum and maximum Riemann invariant values. This helps set the contour levels for our plot\n    minJ = min( minimum( plot_J₊ ), minimum( plot_J₋ ) ) \n    maxJ = max( maximum( plot_J₊ ), maximum( plot_J₊ ) )\n    # Now plot the Riemann invariants as contours\n    p = contour( plot_positions, plot_times, plot_J₊; c=:black, levels=minJ:0.2:maxJ, cbar=false ) # Positive invariants\n    contour!( p, plot_positions, plot_times, plot_J₋; c=:black, levels=minJ:0.2:maxJ ) # Negative invariants\n    savefig( p, \"sod_xt.svg\" )\n    return new_state\nend;","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"There's a lot going on in this function, but fortunately most of it is straightforward and is well explained by the comments. However, there's a few things worth highlighting. In particular, X-T diagrams can be made using quantities such as pressure or density, but Riemann Invariants are a particularly powerful way to visualize the movement of waves within the domain. The Euler equations have positive and negative Riemann invariants, corresponding to rightwards- and leftwards-moving waves, respectively. These are computed using the following lines:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Now compute the Riemann invariants. \n# For this we'll need to interpolate the velocities to zone centers, which we'll do with a simple average\nuₘ = 0.5 .* ( new_state.velocity[1:end-1] .+ new_state.velocity[2:end] )\n# Now compute the Riemann invariants\nJ₊ = uₘ .+ ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Positive Riemann invariant\nJ₋ = uₘ .- ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Negative Riemann invariant","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"These lines first translate the velocity (which is edge-centered) to the zone centers, and then uses that average velocity along with the speed of sound and ratio of specific heats to compute the positive and negative Riemann invariants as a function of space.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now that we have the Riemann invariants, we need to store them for plotting. However, most contour plotting functions (which we will use to plot our X-T diagram) assume that the data is stored on a rectangular grid. In this context, this would mean that the x positions are the same for all time. However, because this is a Lagrangian code, the x positions of the data are not constant as a function of time, so we need to massage the data into a format the contour plotting function can accept. This is done by interpolating the data at a given time back onto the initial grid using the Interpolations.jl package and the following lines: ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"J₊_interp = interpolate( ( new_state.zone_center, ), J₊, Gridded(Linear()) ) # Set up a linear interpolation of our data\nJ₊_extrap = extrapolate( J₊_interp, Line() ) # Linearly extrapolate if needed.\nplot_J₊ = vcat( plot_J₊, J₊_extrap( plot_positions )' ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data\n        \nJ₋_interp = interpolate( ( new_state.zone_center, ), J₋, Gridded(Linear()) ) # Set up a linear interpolation of our data\nJ₋_extrap = extrapolate( J₋_interp, Line() ) # Linearly extrapolate if needed\nplot_J₋ = vcat( plot_J₋, J₋_extrap( plot_positions )' ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The interpolate and extrapolate functions set up this interpolation, and then the vcat lines actually perform the interpolation and append the result to the matricies we're using to store our data.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now that the simulation is done, we'll configure the contour plot to actually produce the X-T diagram. First, we want to compute the minimum and maximum values of the Riemann invariants. We do this so that the contour plots for the positive and negative invariants use the same contour levels, which helps make sure lines are connected to each other and aids in visualization.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# First compute the minimum and maximum Riemann invariant values. This helps set the contour levels for our plot\nminJ = min( minimum( plot_J₊ ), minimum( plot_J₋ ) ) \nmaxJ = max( maximum( plot_J₊ ), maximum( plot_J₊ ) )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can now actually create the contour plot:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Now plot the Riemann invariants as contours\np = contour( plot_positions, plot_times, plot_J₊; c=:black, levels=minJ:0.2:maxJ, cbar=false ) # Positive invariants\ncontour!( p, plot_positions, plot_times, plot_J₋; c=:black, levels=minJ:0.2:maxJ ) # Negative invariants\nsavefig( p, \"sod_xt.svg\" )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"These lines are responsible for actually creating the contour plot. The first line plots the positive (rightwards-moving) Riemann invariants, and the second line adds a plot for the negative (leftwards-moving) Riemann invariants. The optional arguments are c, which sets the line color, levels, which sets the contour levels to plot, and cbar, which tells the plotting routine not to plot a colorbar as it isn't useful in these contexts. Finally, savefig saves the plot to a file called sod_xt.svg.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"tip: Tip\nThe plot colors were set to black as this makes a uniform looking plot. However, you might try plotting the two with different colors (say, c=:red in one plot) as this will show how the positive and negative Riemann invariants correspond to left- and right-moving waves.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"note: Note\nThe levels argument, particularly the step size of 0.2, was tuned to produce a good looking plot for this case. You will probably need to adjust this for other configurations.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"With everything set up we can run our simulation and take a look at our plot. For illustration purposes, the final time in the simulation will be a later time in order to better show the movement of waves in the final plot.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"final_state = run_simulation( init_state, 1.0 )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"and there we go! You can see the leftwards moving expansion wave and the rightwards moving shock and contact surface. Reflections off of the end walls are also visible, as are interactions between different waves. ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"tip: Tip\nYou might notice that things like the material interface look a little wider than might be expected. Try playing around with the artificial_viscosity_coefficient and artificial_conductivity_coefficient values to see what effect these parameters have.","category":"page"},{"location":"Examples/#Modifying-Problem-State","page":"Examples","title":"Modifying Problem State","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"There may be cases where it is desirable to stop and modify the problem state part way through a simulation. For example, to add another shock wave. This can be done using the UpdateSimulationState!() function. This function takes four arguments that are Functions describing the new problem density, velocity, pressure, and ratio of specific heats. However, in this case the functions have a slightly different signature:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"function my_new_state( x, oldValue )\n    ...\nend","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Notice that there is now an oldValue argument. This will hold the current value of the variable at the position x. If you don't want to modify anything, you can just return oldValue from this function.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"As a trivial example, let's say we want to modify the example from the Line Plot section to add a sinusoidal profile to the existing density, set the velocity to zero, and leave everything else untouched. Our functions might look like","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"function update_density( x, oldValue )\n    return 0.05 * sin( 20 * pi * x ) + 0.05 + oldValue # Need to add a value to make sure density doesn't go to zero\nend;\n\nfunction update_velocity( x, oldValue )\n    return 0.0\nend;\n\nfunction update_pressure( x, oldValue )\n    return oldValue\nend;\n\nfunction update_gamma( x, oldValue )\n    return oldValue\nend;","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"With these functions we can now update the problem state:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"UpdateSimulationState!( end_state, update_gamma, update_density, update_velocity, update_pressure )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"and if we plot density again, we'll see the density field has been updated:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"plot( end_state.zone_center, end_state.density );\nsavefig( \"sod_density_updated.svg\" ) # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"and the velocity field is now zero everywhere:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"plot( end_state.zone_edge, end_state.velocity );\nsavefig( \"sod_velocity_updated.svg\" ) # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"caution: Caution\nThe functions to update the simulation state were chosen to be illustrative, and it's likely the simulation would be unstable following this change. Care should be taken to ensure the updated state makes sense.","category":"page"},{"location":"FunctionReference/#Function-Reference","page":"Function Reference","title":"Function Reference","text":"","category":"section"},{"location":"FunctionReference/#Problem-Configuration","page":"Function Reference","title":"Problem Configuration","text":"","category":"section"},{"location":"FunctionReference/#Euler1D.DefaultSimulationParameters","page":"Function Reference","title":"Euler1D.DefaultSimulationParameters","text":"DefaultSimulationParameters()\n\nReturn a set of default parameters for a simulation.\n\nReturns\n\nA Dict{String, Any} with default parameters for a simulation. \n\nNotes\n\nKeys with a value of nothing must be set before using this dictionary to initialize a simulation. This is done instead of providing a default function to avoid the possibility of accidentally initializing a simulation with unintended initial conditions.\n\nParameters\n\nstart_time: The initial time of the simulation. (Unit: s; Default: 0.0)\nend_time: The final time of the simulation. (Unit: s; Default: 1.0)\nstart_position: The position of the left side of the domain. (Unit: m; Default: 0.0)\nend_position: The position of the right side of the domain. (Unit: m; Default: 1.0)\nnumber_of_zones: The number of zones to divide the domain into. (Unit: ⋅; Default: 1000)\nCFL: The CFL number to use. (Unit: ⋅; Default: 0.2)\nartificial_viscosity_coefficient: The coefficient to use for artificial viscosity. (Unit: ⋅; Default: 1e0)\nartificial_conductivity_coefficient: The coefficient to use for artificial conductivity. (Unit: ⋅; Default: 1e-2)\nmin_timestep: The minimum allowable timestep size. Simulation will halt if timestep falls below this value. (Unit: s; Default: 1e-7)\nmax_cycles: The maximum number of cycles to perform. Simulation will halt if more than this many timesteps are taken. (Unit: ⋅; Default: 1e6)\ninit_density_function: A Function that returns the initial density as a function of position x. (Unit: kg/m³; Default: nothing, must be user-supplied)\ninit_velocity_function: A Function that returns the initial velocity as a function of position x. (Unit: m/s; Default: nothing, must be user-supplied)\ninit_pressure_function: A Function that returns the initial pressure as a function of position x. (Unit: N/m²; Default: nothing, must be user-supplied)\ninit_gamma_function: A Function that returns the ratio of specific heats as a function of position x. (Unit: ⋅; Default: nothing, must be user-supplied)\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.InitializeSimulation","page":"Function Reference","title":"Euler1D.InitializeSimulation","text":"InitializeSimulation( parameters::Dict{String, Any} )\n\nInitialize a simulation with the parameters provided by parameters. A default set of parameters can be returned from the DefaultSimulationParameters() function.\n\nReturns\n\nA struct of type Simulation{T} that describes the current simulation state. The type T is determined by the type of the members of parameters.\n\nNotes\n\nThis function performs some basic sanity checking on input parameters such as ensuring that end_time > start_time or end_position > start_position, and will raise an error if any of these checks fail.\nA warning will be raised if any keys in the dictionary are unused, but this will not halt execution.\nThis function will not warn about any potential issues with problem configuration or potential stability issues.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.UpdateSimulationState!","page":"Function Reference","title":"Euler1D.UpdateSimulationState!","text":"UpdateSimulationState!( state::Simulation{T}, gamma::Function, density::Function, velocity::Function, pressure::Function ) where { T <: AbstractFloat }\n\nUpdate the simulation state using the supplied functions to define a new state. See Notes for information about the expected signature of the functions.\n\nReturns\n\nnothing. Updates the state input in-place.\n\nArguments\n\nstate: A Simulation{T} representing the simulation state to be updated\ngamma: A Function that returns the new values of the ratio of specific heats, gamma\ndensity: A Function that returns the new values of the density\nvelocity: A Function that returns the new values of velocity\npressure: A Function that returns the new values of pressure\n\nNotes\n\nUnlike the functions used in initial problem setup, the functions supplied to UpdateSimulationState have a slightly different expected signature of     ExampleFunction( x::T, oldValue::T ) where { T <: AbstractFloat } where oldValue will be the current value of the state variable at current position x (e.g., the previous value of pressure).\n\nSide Effects\n\nUpdates the values stored in the vectors for state.gamma, state.mass, state.velocity, state.intenergy, and fields derived from the equation of state in-place.\n\nwarning: Warning\nIf the density function alters the state.density field (that is, it does not just return oldValue), mass will be added or removed from a given zone to achieve a specified value of density without changing zone size. As a consequence, mass will not be conserved in the system in this case.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Timestepping","page":"Function Reference","title":"Timestepping","text":"","category":"section"},{"location":"FunctionReference/#Euler1D.AdvanceToTime","page":"Function Reference","title":"Euler1D.AdvanceToTime","text":"AdvanceToTime( state::Simulation{T}, stoptime::T, Δt::T; exact::Bool=false ) where { T <: AbstractFloat }\n\nAdvance the simulation with initial state state to a time specified by stoptime with a fixed timestep. \n\nReturns\n\nA Simulation{T} representing the state at the end of the final cycle.\n\nArguments\n\ninput: A Simulation{T} representing the simulation state at the start of the first cycle.\nstoptime: The time to advance to. (Unit: s)\nΔt: The timestep size. (Unit: s)\nexact: If true, try to stop as close as possible to stoptime by adjusting the final timestep size (Default: false)\n\nNotes\n\nThe current simulation time is determined by the Simulation field state.time. If state.time > stoptime, no steps will be taken.\nThis function allocates two deepcopy()s of the input state and returns the copy corresponding to the final state.\nThis function simply calls AdvanceOneCycle! repeatedly until the simulation time reaches stoptime. The primary advantage to using this function as opposed to AdvanceOneCycle() or AdvanceNCycles() is that various backing arrays are pre-allocated to improve speed.\nIf exact=true, the timestep of the final cycle is adjusted so that the time of the final state is as close as possible to stoptime.\n\n\n\n\n\nAdvanceToTime( state::Simulation{T}, stoptime::T; exact::Bool=false ) where { T <: AbstractFloat }\n\nAdvance the simulation with initial state state to a time specified by stoptime with a variable timestep. \n\nReturns\n\nA Simulation{T} representing the state at the end of the final cycle\n\nArguments\n\ninput: A Simulation{T} representing the simulation state at the start of the first cycle.\nstoptime: The time to advance to. (Unit: s)\nexact: If true, try to stop as close as possible to stoptime by adjusting the final timestep size (Default: false)\n\nNotes\n\nThe current simulation time is determined by the Simulation field state.time. If state.time > stoptime, no steps will be taken.\nThis function allocates two deepcopy()s of the input state and returns the copy corresponding to the final state.\nThis function simply calls AdvanceOneCycle!() repeatedly until the simulation time reaches stoptime. The primary advantage to using this function as opposed to AdvanceOneCycle() or AdvanceNCycles() is that various backing arrays are pre-allocated to improve speed.\nThe timestep size, Δt, is determined for each cycle based on the minimum time for an acoustic wave to traverse a zone. See the documentation for CalculateTimestepSize() for further details. \nIf exact=true, the timestep of the final cycle is adjusted so that the time of the final state is as close as possible to stoptime.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.AdvanceOneCycle","page":"Function Reference","title":"Euler1D.AdvanceOneCycle","text":"AdvanceOneCycle( state::Simulation{T}, Δt::T ) where { T <: AbstractFloat }\n\nAdvance the simulation by one cycle with a timestep of Δt.\n\nReturns\n\nA Simulation{T} representing the state at the end of the cycle\n\nArguments\n\ninput: A Simulation{T} representing the simulation state at the start of the cycle.\nΔt: The size of the time step. (Unit: s)\n\nNotes\n\nThis function allocates a deepcopy() of the input state. The copy is modified and returned from this function.\n\n\n\n\n\nAdvanceOneCycle( state::Simulation{T} ) where { T <: AbstractFloat }\n\nAdvance the simulation by one cycle. \n\nReturns\n\nA Simulation{T} representing the state at the end of the cycle\n\nArguments\n\ninput: A Simulation{T} representing the simulation state at the start of the cycle\n\nNotes\n\nThis function allocates a deepcopy() of the input state and returns the copy.\nThe timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See CalculateTimestepSize() for further details.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.AdvanceOneCycle!","page":"Function Reference","title":"Euler1D.AdvanceOneCycle!","text":"AdvanceOneCycle!( output::Simulation{T}, input::Simulation{T}, Δt::T ) where { T <: AbstractFloat }\n\nAdvance the simulation by one cycle with a timestep of Δt.\n\nReturns\n\nnothing. Modifies output in-place.\n\nArguments\n\noutput: A Simulation{T} that will represent the output state. This will be modified by the function to represent the simulation state after advancing one cycle.\ninput: A Simulation{T} that represents the simulation state at the start of the cycle.\nΔt: The size of the time step. (Unit: s)\n\nSide Effects\n\nAll fields of output are modified in-place.\n\n\n\n\n\nAdvanceOneCycle!( output::Simulation{T}, input::Simulation{T} ) where { T <: AbstractFloat }\n\nAdvance the simulation by one cycle. \n\nReturns\n\nnothing. Modifies output in-place.\n\nArguments\n\noutput: A Simulation{T} that will represent the output state. This will be modified by the function to represent the simulation state after advancing one cycle.\ninput: A Simulation{T} representing the simulation state at the start of the cycle\n\nNotes\n\nThe timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See CalculateTimestepSize() for further details.\n\nSide Effects\n\nAll fields of output are modified in-place.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.AdvanceNCycles","page":"Function Reference","title":"Euler1D.AdvanceNCycles","text":"AdvanceNCycles( state::Simulation{T}, ncycles::UInt, Δt::T ) where { T <: AbstractFloat }\n\nAdvance the simulation by ncycles cycles with a fixed timestep.\n\nReturns\n\nA Simulation{T} representing the state at the end of the final cycle\n\nArguments\n\ninput: A Simulation{T} representing the simulation state at the start of the first cycle.\nncycles: The number of cycles to advance.\nΔt: The size of the time step. (Unit: s)\n\nNotes\n\nThis function allocates two deepcopy()s of the input state and returns the copy corresponding to the final state.\nThis function calls AdvanceOneCycle!() a total of ncycles times to advance the simulation. The primary advantage to using this function as opposed to AdvanceOneCycle() if the number of cycles to advance is known is that various backing arrays are pre-allocated to improve speed.\n\n\n\n\n\nAdvanceNCycles( state::Simulation{T}, ncycles::UInt ) where { T <: AbstractFloat }\n\nAdvance the simulation by ncycles cycles with a variable timestep. \n\nReturns\n\nA Simulation{T} representing the state at the end of the final cycle\n\nArguments\n\ninput: A Simulation{T} representing the simulation state at the start of the first cycle.\nncycles: The number of cycles to advance. (Unit: ⋅)\n\nNotes\n\nThis function allocates two deepcopy()s of the input state and returns the copy corresponding to the final state.\nThis function calls AdvanceOneCycle!() a total of ncycles times to advance the simulation. The primary advantage to using this function as opposed to AdvanceOneCycle() if the number of cycles to advance is known is that various backing arrays are pre-allocated to improve speed.\nThe timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See CalculateTimestepSize() for further details.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.CalculateTimestepSize","page":"Function Reference","title":"Euler1D.CalculateTimestepSize","text":"CalculateTimestepSize( state::Simulation{T} ) where { T <: AbstractFloat }\n\nCompute an automatic timestep size for the next simulation cycle based on the current simulation state. See the Notes section for details on how the timestep is determined.\n\nReturns\n\nA scalar of type T representing the timestep size for the next cycle based on the current simulation state.\n\nArguments\n\nstate: A Simulation{T} representing the problem state.\n\nNotes\n\nFor each zone, the local speed of sound is computed according to c = √( γ P / ρ ), where γ, P, and ρ are the ratio of specific heats, the pressure, and the density of the gas in that zone.\nThe time for an acoustic wave to traverse a zone with length Δx is computed as t = Δx / c.\nThe minimum traversal time for all zones is multiplied by the user-specified CFL number to obtain the timestep size.\nSanity checking for negative zone sizes and small timesteps is performed to detect problem instability.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Equation-of-State","page":"Function Reference","title":"Equation of State","text":"","category":"section"},{"location":"FunctionReference/#Euler1D.EOS_Density","page":"Function Reference","title":"Euler1D.EOS_Density","text":"EOS_Density( mass::T, Δx::T ) where { T <: AbstractFloat } = mass / Δx\n\nCompute the density of the fluid in a zone.\n\nReturns\n\nA scalar of type T representing the density of a zone.\n\nArguments\n\nmass: The total mass contained within the zone. (Unit: kg)\nΔx: The size of the zone. (Unit: m)\n\nNotes\n\nDensity is calculated as:\n\nρ = mass / Δx\n\nAs this is the physical definition of density, this calculation does not assume any particular equation of state.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.EOS_Pressure","page":"Function Reference","title":"Euler1D.EOS_Pressure","text":"EOS_Pressure( γ::T, ρ::T, e::T ) where { T <: AbstractFloat }\nEOS_Pressure( γ::T, mass::T, Δx::T, e::T ) where { T <: AbstractFloat }\n\nCompute the pressure of a zone using an ideal gas equation of state.\n\nReturns\n\nA scalar of type T representing the pressure within the zone.\n\nArguments\n\nγ: The ratio of specific heats of the fluid in the zone. (Unit: ⋅)\nρ: The density of the zone. (Unit: kg/m³)\nmass: The total mass contained within the zone. (Unit: kg)\nΔx: The size of the zone. (Unit: m)\ne: The internal energy per unit mass of the zone. (Unit: m²/s²)\n\nNotes\n\nThe pressure is calculated as:\n\nP = ( γ - 1 ) ⋅ ρ ⋅ e\n\nThe four-parameter version of this function computes density using EOS_Density(). See the documentation for that function for further details.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.EOS_SpeedOfSound","page":"Function Reference","title":"Euler1D.EOS_SpeedOfSound","text":"EOS_SpeedOfSound( γ::T, P::T, ρ::T ) where { T <: AbstractFloat }\nEOS_SpeedOfSound( γ::T, e::T, mass::T, Δx::T ) where { T <: AbstractFloat }\n\nCompute the speed of sound in a zone using an ideal gas equation of state.\n\nReturns\n\nA scalar of type T representing the speed of sound in the zone.\n\nArguments\n\nγ: The ratio of specific heats in the zone. (Unit: ⋅)\ne: The internal energy per unit mass in the zone. (Unit: m²/s²)\nP: The pressure in the zone. (Unit: kg/(m⋅s²))\nρ: The density of the fluid in the zone. (Unit: kg/m³)\nmass: The mass contained in the zone. (Unit: kg)\nΔx: The length of the zone. (Unit: m)\n\nNotes\n\nThe speed of sound is calculated as:\n\nc = √( γ * P / ρ )\n\nThe four-parameter version of this function computes density using EOS_Density() and pressure using EOS_Pressure(). See the documentation of those functions for further details.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Artificial-Dissipation","page":"Function Reference","title":"Artificial Dissipation","text":"","category":"section"},{"location":"FunctionReference/#Euler1D.artificial_viscosity","page":"Function Reference","title":"Euler1D.artificial_viscosity","text":"artificial_viscosity( Cᵥ::T, c::T, ρ::T, Δx::T, u₋::T, u₊::T ) where { T <: AbstractFloat }\n\nCompute an artificial viscosity within a zone. \n\nReturns\n\nA value of type T representing the value of the artificial viscosity.\n\nArguments\n\nCᵥ: An O(1) coefficient to control the strength of the artificial viscosity. (Unit: ⋅)\nc: The speed of sound in the zone. (Unit: m/s)\nρ: The density of the zone. (Unit: kg/m³)\nΔx: The length of the zone. (Unit: m)\nu: The velocity of the zone boundaries, with superscripts - and + referring to the left and right boundaries of the zone, respectively. (Unit: m/s)\n\nNotes\n\nThis artificial viscosity is based on the method described by Wilkins (1980), which in turn relies upon the methods of Von Neumann and Richtmyer (1950) and Landschoff (1955). The values computed by this function should be added to the pressure field during governing equation updates.\nThis function returns zero if ∂u/∂x > 0, which will be the case for regions where the flow is expanding. This is done to restrict artificial viscosity only to regions of compression.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.artificial_conductivity","page":"Function Reference","title":"Euler1D.artificial_conductivity","text":"artificial_conductivity( Cₖ::T, u::T, c₋::T, e₋::T, Δx₋::T, c₊::T, e₊::T, Δx₊::T ) where { T <: AbstractFloat }\n\nCompute an artificial flux of internal energy across a zone interface.\n\nReturns\n\nA value of type T representing the artifical flux of internal energy across a zone boundary.\n\nArguments\n\nCₖ: An O(1) coefficient to control the strength of the artificial conductivity. (Unit: ⋅)\nu: The velocity of the zone interface. (Unit: m/s)\nc: The speed of sound, where superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m/s)\ne: The internal energy per unit mass. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m²/s²)\nΔx: Length of the zone. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m)\n\nNotes\n\nThe artificial conductivity is modeled as a Fickian diffusivity. That is, the flux of energy across a zone boundary, fₑ, is described by\n\nfₑ = -κ ∂e/∂x\n\nwhere e is the internal energy per unit mass and κ is the (artificial) conductivity coefficient. The gradient of internal energy is treated with a simple forward finite difference. The artificial conductivity coefficient is modeled as\n\nκ = Cₖ * cₘ * Δx\n\nwhere\n\nCₖ an O(1) coefficient.\ncₘ  is a characteristic velocity taken to be max(c̄±u, c̄), where c̄=0.5*(c₋+c₊) is the average speed of sound of the two adjacent zones and u is the velocity of the zone interface. \nΔx is the distance between the zone centers\n\nBy convention, this leads to a positive flux if energy is diffusing in the positive x direction, and negative if it is diffusing in the negative x direction.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Types","page":"Function Reference","title":"Types","text":"","category":"section"},{"location":"FunctionReference/#Euler1D.Simulation","page":"Function Reference","title":"Euler1D.Simulation","text":"struct Simulation{T}\n\nA structure containing all the internal variables and arrays used in the simulation.\n\nParameters\n\nnzones::Int: The number of zones in the simulation. (Unit: ⋅)\nnedges::Int: The number of zone edges in the simulation, equal to nzones + 1. (Unit: ⋅)\nCFL::Float64: The CFL number to be used when calculating timesteps. (Unit: ⋅)\nstart_time::Float64: The initial time of the simulation. (Unit: s)\nviscosity_coefficient::Float64: The coefficient used to scale artificial viscosity. (Unit: ⋅)\nconductivity_coefficient::Float64: The coefficient used to scale artificial conductivity. (Unit: ⋅)\ntime::Base.RefValue{T}: The current time of the simulation. (Unit: s)\ndt::Base.RefValue{T}: The size of the timestep taken in the last cycle. (Unit: s)\ncycles::Base.RefValue{UInt}: The number of cycles performed so far. (Unit: ⋅)\nmin_dt::Float64: The minimum allowable timestep size. Simulation will halt if Δt falls below this value. (Unit: s)\nmax_cycles::UInt: The maximum number of cycles to perform. Simulation will halt if cycles exceeds this value. (Unit: ⋅)\nzone_edge::Vector{T}: A vector of locations of zone edges. Increases monotonically. (Unit: m)\nzone_center::Vector{T}: A vector of locations of zone centers, defined as the midpoint between two zone edges. Increases monotonically. (Unit: m)\nzone_length::Vector{T}: A vector of the length of each zone. (Unit: m)\ngamma::Vector{T}: A vector of the ratio of specific heats inside each zone. (Unit: ⋅)\nmass::Vector{T}: A vector of the mass contained within each zone. Assumed constant. (Unit: kg)\ndensity::Vector{T}: A vector of the density of the fluid within each zone. Computed using the equation of state as mass/Δx. (Unit: kg/m³)\nvelocity::Vector{T}: A vector of velocities of zone edges. (Unit: m/s)\npressure::Vector{T}: A vector of pressures inside each zone. Computed from the equation of state. (Unit: kg/(m⋅s²))\nintenergy::Vector{T}: A vector of the internal energy per unit mass of each zone. (Unit: m²/s²)\nspeedofsound::Vector{T}: A vector of the speed of sound within each zone. Computed from the equation of state. (Unit: m/s)\nviscosity::Vector{T}: A vector of the artificial viscosity within each zone, added to the pressure field. See ArtificialDissipation.jl for more information. (Unit: kg/(m⋅s²))\nenergy_flux::Vector{T}: A vector of fluxes of internal energy per unit mass across each zone boundary. Added to the energy equation as a diffusion term. See ArtificialDissipation.jl for more information. (Unit: m³/s³)\nmomentum_rhs::Vector{T}: A vector of the right hand side of the momentum equation at each zone edge. (Unit: m/s²)\nenergy_rhs::Vector{T}: A vector of the right hand side of the energy equation within each zone. (Unit: m²/s³)\n\n\n\n\n\n","category":"type"},{"location":"FunctionReference/#Governing-Equations","page":"Function Reference","title":"Governing Equations","text":"","category":"section"},{"location":"FunctionReference/","page":"Function Reference","title":"Function Reference","text":"note: Note\nThese functions are not intended to be called directly as part of simulation setup. However, as their functionality is central to this package, they are documented here for reference.","category":"page"},{"location":"FunctionReference/#Euler1D.Momentum","page":"Function Reference","title":"Euler1D.Momentum","text":"Momentum( m₋::T, P₋::T, m₊::T, P₊::T ) where { T <: AbstractFloat }\n\nCompute the right hand side of the momentum equation at a zone interface. See the Notes section for information on the equation being solved.\n\nReturns\n\nA scalar of type T representing the rate of change of velocity of a zone interface over time.\n\nArguments\n\nm: The mass of the zone. (Unit: kg)\nP: The pressure of the zone (Unit: kg/(m⋅s²))\n\nFor each of these parameters, a - subscript refers to the zone to the left of the zone interface and a + subscript refers to the zone to the right of the zone interface.\n\nNotes\n\nThe governing equation solved in this function is:     ∂u/∂t = (1/ρ₀) * ∂P/∂x Through the numerical disretization, this reduces to     ∂u/∂t = 1/m̄ ( P₊ - P₋ ) If using artificial viscosity per the method of Von Neumann and Richtmyer (1950), the artificial viscosity term should be added to the pressure field.\n\n\n\n\n\n","category":"function"},{"location":"FunctionReference/#Euler1D.Energy","page":"Function Reference","title":"Euler1D.Energy","text":"Energy( ρ::T, P::T, Δx::T, u₋::T, u₊::T, q₋::T, q₊::T ) where { T <: AbstractFloat }\n\nCompute the right hand side of the energy equation in a zone. See the Notes section for the specific equations that are solved.\n\nReturns\n\nA scalar of type T representing the rate of change of internal energy inside the zone.\n\nArguments\n\nm: The mass of the zone. (Unit: kg)\nP: The pressure of the zone. (Unit: kg/(m⋅s²))\nΔx: The length of the zone. (Unit: m)\nu: The velocity of the zone edges on the (-): left and (+): right of the zone. (Unit: m/s)\nq: The (artificial) flux of internal energy across the (-): left and (+): right zone edges. (Unit: m³/s³) \n\nNotes:\n\nThe governing equation solved in this function is     ∂e/∂t = - ( P / ρ₀ ) * ∂u/∂x + ∑q Through discretization, this becomes     ∂eᵢ/∂t = - ( Pᵢ / mᵢ ) * ( u₊ - u₋ ) + ∑q \n\n\n\n\n\n","category":"function"},{"location":"#Euler1D","page":"Euler1D","title":"Euler1D","text":"","category":"section"},{"location":"","page":"Euler1D","title":"Euler1D","text":"This is a package that solves the one-dimensional compressible Euler equations on a Lagrangian (moving) mesh and assuming an ideal gas equation of state. ","category":"page"},{"location":"","page":"Euler1D","title":"Euler1D","text":"The primary contribution of this package is intended to be as a demonstration of how a hydrodynamics code can be implemented entirely in Julia, including problem setup, the simulation code itself, and results postprocessing. In this way, there is no need to maintain a separate parser to interpret \"input decks\" for configuring the intial problem state. The language used to set up the problem is the same as the one used to perform the simulation. As long as the language supports it, it can be used with no modification to this package. Ideally, this can all be done while maintaining relative parity in execution time with similar codes written in compiled languages (C, C++, Fortran, etc).","category":"page"},{"location":"","page":"Euler1D","title":"Euler1D","text":"This README is broken into several sections:","category":"page"},{"location":"#Installation","page":"Euler1D","title":"Installation","text":"","category":"section"},{"location":"","page":"Euler1D","title":"Euler1D","text":"Installation of this package is straightforward. At the Julia REPL, type","category":"page"},{"location":"","page":"Euler1D","title":"Euler1D","text":"julia> # Press ] key\npkg> add https://www.github.com/fergu/Euler1D.git","category":"page"},{"location":"","page":"Euler1D","title":"Euler1D","text":"or, alternatively","category":"page"},{"location":"","page":"Euler1D","title":"Euler1D","text":"julia> using Pkg\njulia> Pkg.add(\"https://www.github.com/fergu/Euler1D.git\")","category":"page"},{"location":"#Usage","page":"Euler1D","title":"Usage","text":"","category":"section"},{"location":"","page":"Euler1D","title":"Euler1D","text":"At its core, using Euler1D.jl relies on a single Julia file to describe simulation setup, running of the simulation, and processing of outputs. The Examples page shows how to set up and run a simulation, and post-process its outputs. The examples subdirectory also contains ready-to-run examples as well.","category":"page"},{"location":"#Roadmap","page":"Euler1D","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Euler1D","title":"Euler1D","text":"This section describes ideas for future functionality that could be added. Underneath each bullet point below are a few notes on additional functionality that might need to be implemented to support that idea.","category":"page"},{"location":"","page":"Euler1D","title":"Euler1D","text":"Just because something is included here does not mean it is being actively worked on, and just because something isn't included doesn't mean it isn't of interest. If you are interested in contributing to any of these ideas or one of your own, feel free to open an issue or a pull request.","category":"page"},{"location":"","page":"Euler1D","title":"Euler1D","text":"Register this package with the Julia package index to simplify installation (After V1.0)\nSupport for RANS models to describe, e.g., mixing across a material interface\nWill require treatment of mixtures, including updating calls to the equation of state to calculate mixture properties\nWill probably require tracking of individual species mass fraction fields, which is not currently supported.\nSupport for an adaptable initial distribution of grid points, with the hope that there is less difference between the timestep requirements of the smallest and largest zones.\nThis could, for example, use the supplied initial condition functions to compute a local speed of sound and adjust the location of the next zone based on that number.\nThe downside is that information on, for example, the zone that corresponds to a given initial location is a bit harder to track\nThis is potentially addressed by introducing passive tracers that move with the local velocity\nSupport for passive tracer particles\nParticles that move exactly with the local flow velocity. This is potentially useful for things like interface tracking given the Lagrangian nature of the solution.","category":"page"},{"location":"Methodology/#Methodology","page":"Methodology","title":"Methodology","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"note: Note\nThe documentation on this page is mainly provided for informational purposes. While it is always good to understand what a numerical code is doing before relying on the answers it gives, this information is not strictly necessary to run Euler1D.","category":"page"},{"location":"Methodology/#Overview","page":"Methodology","title":"Overview","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"This package is a solver for the Euler equations in one dimension on a Lagrangian mesh with an ideal gas equation of state. Thermodynamic quantities (e.g., internal energy, density, pressure) are located at zone centers, and kinematic quantities (e.g., position, velocity) are located at zone edges. As this code is Lagrangian, the mass within a zone is constant and is stored at zone centers. Zone centers are indexed with integers (e.g., i, i+1, i+2, etc, where i is an integer), and zone edges are fractionally indexed (e.g., i-12, i+12, etc)","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Spatial discretization is performed using central differences, making the solution second order in smooth regions though the solution may degrade to first order in the neighborhood of discontinuities such as shocks. Further details on the governing equations, including their spatial discretization, is shown in Equations of Motion.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Time discretization is performed using a first-order explicit Euler integration. For a parameter f and the value of the right hand side of the governing equation for f, mathrmRHS (such as would be found using the equations shown in Equations of Motion), the time integration from time index n to n+1 can be written as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"frac partial f partial t = frac f^n+1 - f^n  t^n+1 - t^n  = mathrmRHS^n ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Recognizing that t^n+1 - t^n = Delta t is the timestep size, this equation can be rearranged to obtain the new state at the next time index as:","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"boxed f^n+1 = f^n + Delta t cdot mathrmRHS^n ","category":"page"},{"location":"Methodology/#equations-of-motion-theory","page":"Methodology","title":"Equations of Motion","text":"","category":"section"},{"location":"Methodology/#Momentum-Equation","page":"Methodology","title":"Momentum Equation","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The momentum equation solved by this package is given by equation 3 in von Neumann and Richtmyer [1]:","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"fracpartial upartial t = - frac1rho_0 fracpartial Ppartial x","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where u is the velocity, P is the pressure, rho_0 is the initial density, and t and x are time and position, respectively.","category":"page"},{"location":"Methodology/#Numerical-Discretization","page":"Methodology","title":"Numerical Discretization","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Semi-discretizing the momentum equation at the zone interface with index i+12:","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"fracpartial u_i+12partial t = - frac1rho_0 frac P_i+1 - P_i  x_i+1 - x_i  ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Internally, the code tracks the location of zone edges (e.g., x_i+12), and infers the position of a zone center from the location of the left and right zone edges as x_i = ( x_i+12 + x_i-12 )  2. Therefore, the above expression can be written in terms of the locations of the zone edge locations as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"fracpartial u_i+12partial t = - frac1rho_0 frac P_i+1 - P_i  frac12 (x_i+32 + x_i+12 ) - frac12 ( x_i+12 + x_i-12 )  ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Noting that x_i+12 - x_i-12 = Delta x_i, the length of the i-th zone, this can be further simplified to obtain","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"fracpartial u_i+12partial t = - frac1rho_0 frac P_i+1 - P_i  frac12 (Delta x_i+1 + Delta x_i)  ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Finally, recognizing that rho_0i Delta x_i = m_i is the (constant) mass in zone i, the discretized equation is obtained as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"boxed fracpartial u_i+12partial t = - frac1barm_i+12 ( P_i+1 - P_i ) ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where barm_i+12 = frac12 ( m_i+1 + m_i ) is the average mass of the zones to the left and right of the interface.","category":"page"},{"location":"Methodology/#Energy-Equation","page":"Methodology","title":"Energy Equation","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The equation for internal energy per unit mass is given in equation 4 of von Neumann and Richtmyer [1] as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"fracpartial epartial t = - fracPrho_0 fracpartial upartial x","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where e is the internal energy per unit mass.","category":"page"},{"location":"Methodology/#Numerical-Discretization-2","page":"Methodology","title":"Numerical Discretization","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"A similar procedure as the momentum equation is undertaken for the discretization of the energy equation. Semi-discretizing the energy equation for a zone with index i yields","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"fracpartial epartial t = - fracP_irho_0 fracu_i+12 - u_i-12x_i+12 - x_i-12 ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Noting that x_i+12 - x_i-12 = Delta x_i is the length of the i-th zone, and recalling that rho_0 Delta x_i = m_i, this expression can be simplified to","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"boxedfracpartial epartial t = - fracP_im_i (u_i+12 - u_i-12 ) ","category":"page"},{"location":"Methodology/#Equations-of-State","page":"Methodology","title":"Equations of State","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"This code directly evolves momentum (or, more precisely, the velocity of zone edges and thus zone length) and internal energy per unit mass within each zone. Additionally, by virtue of using a Lagrangian method, mass within each zone is constant. All other quantities are derived from these quantities assuming an ideal gas equation of state. This section enumerates the derived quantities and the mathematical formulas used to compute them.","category":"page"},{"location":"Methodology/#Density","page":"Methodology","title":"Density","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Density is derived from the size of a zone at each timestep according to","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"rho_i = frac m_i  Delta x_i ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where rho_i is the density of the i-th zone, m_i is the mass contained in the zone, and Delta x_i is the length of the zone. The mass initially inside each zone is computed at the time of simulation initialization. Given a function for density and a known zone length, the mass within each zone is initialized as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"m_i = rho_i Delta x_i ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The function used to compute density in a given zone is EOS_Density().","category":"page"},{"location":"Methodology/#Pressure","page":"Methodology","title":"Pressure","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Pressure is derived from the density and internal energy per unit mass according to","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"P_i = (gamma_i - 1) rho_i e_i","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where P_i is the pressure in the i-th zone, gamma is the the ratio of specific heats for the gas in the zone, rho_i is the density, and e_i is the internal energy per unit mass. The function used to compute pressure in a zone is EOS_Pressure(), and internally the density is computed using EOS_Density().","category":"page"},{"location":"Methodology/#Speed-of-Sound","page":"Methodology","title":"Speed of Sound","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The speed of sound, c, within a zone is calculated as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"c_i = sqrt gamma_i fracP_irho_i ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Speed of sound is computed using the function EOS_SpeedOfSound(). Internally, the pressure in this expression is found using EOS_Pressure() and the density in this expression is found using EOS_Density(). ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"note: Note\nIt is important to highlight that the equations shown in this section are written using derived quantities (e.g., pressure being a function of density) in order to be similar to existing literature and thus be more understandable. However, this does not exactly align with what this package does internally. Internally, any derived quantity is evaluated directly from evolved quantities and the appropriate equations of state, not from any of the derived fields.","category":"page"},{"location":"Methodology/#artificial-dissipation-theory","page":"Methodology","title":"Artificial Dissipation","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Numerical solutions often form oscillations in the neighborhood of solution discontinuities, such as shock waves. To combat this, an artificial viscosity term is added to the pressure field, and an artificial conductivity term is added to the energy equation. These terms act to spread discontinuities over several zones and thus dampen these oscillations. This section describes the mathematical form of each of these terms.","category":"page"},{"location":"Methodology/#Artificial-Viscosity","page":"Methodology","title":"Artificial Viscosity","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Von Neumann and Richtmyer [1] initially introduced an artificial viscosity term that is added to the pressure field while solving the governing equations, P_t = P_a + q_v, where P is the pressure, P_a is the actual (computed from the equation of state) pressure, and q_v is an artifical addition. Mathematically, the expression used in [1] is","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"q_vnr = - C_v rho (cDelta x)^2 fracpartial upartial x cdot left fracpartial upartial x right","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where q_vnr is the artificial von Neumann-Richtmyer viscosity, C_v is an O(1) dimensionless coefficient (and not to be confused with hatc_v, the dimensionless heat capacity at constant volume), and c is the local speed of sound. Later, Landshoff [2] introduced a different definition that was instead linear in the velocity gradient:","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"q_l = C_v rho Delta x c left fracpartial upartial x right","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where q_l is the Landshoff artificial viscosity. Wilkins [3] combined these two definitions into a single expression,","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"boxed q_v = c_vnr + q_l = - C_v rho (cDelta x)^2 fracpartial upartial x cdot left fracpartial upartial x right + C_v rho c Delta x left fracpartial upartial x right ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"This is the expression used for artificial viscosity in this package and is computed by the function artificial_viscosity(). Numerically, this artificial viscosity is zone-centered to be aligned with the pressure field. Derivatives of velocity are computed identically to the method used in the computation of pressure, left( partial upartial x right)_i = ( u_i+12 - u_i-12 )  Delta x_i.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"info: Info\nThe same tuning coefficient, C_v, is used for both the von Neumann-Richtmyer and Landshoff components of artificial viscosity.","category":"page"},{"location":"Methodology/#Artificial-Conductivity","page":"Methodology","title":"Artificial Conductivity","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The artificial viscosity is based on velocity gradients, and so will not be active in regions where the solution is continuous in velocity but discontinuous in internal energy or density, such as would be the case in the neighborhood of a contact surface. To address this, this package additionally adds artificial diffusion of internal energy to smooth discontinuities in the internal energy field. Mathematically, this is treated as a Fickian diffusion, where the flux of internal energy across a zone edge is","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"J_e = kappa fracpartial epartial x","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where J_e is the flux of internal energy across a zone edge and kappa is a diffusion coefficient, modeled as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"kappa = C_k c_m Delta x","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where C_k is an O(1) dimensionless coefficient and c_m is a characteristic velocity. By convention, a positive value of J_e represents energy flux in the positive x direction, and a negative value of J_e represents flux in the negative x direction. As J_e represents a flux and is thus located on zone edges, this package computes c_m at a zone edge as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"c_mi+12 = mathrmmax( barc_i+12 pm u_i+12 barc_i+12 )","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where barc_i+12 = frac12 ( c_i + c_i+1 ) is the average speed of sound of the zones to the left and right of the interface. ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The flux of internal energy is added to the energy equation as","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"fracpartial epartial t = cdots + q_e","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where q_e is","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"q_e = fracpartialpartial x left( kappa fracpartial epartial x right) = fracpartialpartial xleft( J_e right) ","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Numerically, this term is discretized using the same procedure as the rest of the energy equation to obtain","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"q_ei = frac J_ei+12 - J_ei-12 x_i+12 - x_i-12 = frac1Delta x_i ( J_ei+12 - J_ei-12 )","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Internally, this term is computed using artificial_conductivity().","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"caution: Caution\nArtificial conductivity is useful for suppressing oscillations near contact surfaces and stabilizing problems with multiple shock waves, but can also result in material interfaces and contact surfaces becoming unphysically diffuse over long time periods. Generally this term should be small compared to the artificial viscosity, C_k ll C_v.","category":"page"},{"location":"Methodology/#References","page":"Methodology","title":"References","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"[1] von Neumann, J. and Richtmyer, R. D. \"A method for the numerical calculation of hydrodynamic shocks\". J. Appl. Phys. (21) pp 232-237 (1950) DOI: 10.1063/1.1699639\n[2] Landshoff, R., \"A Numerical Method for Treating Fluid Flow in the Presence of Shocks\", Los Alamos Scientific Laboratory Report LA-1930 (1955) Link\n[3] Wilkins, M. L., \"Use of Artificial Viscosity in Multidimensional Fluid Dynamic Calculations\". J. Comp. Phys. (36) pp 281-303 (1980) DOI: 10.1016/0021-9991(80)90161-8","category":"page"}]
}
