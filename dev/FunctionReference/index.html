<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · Euler1D</title><meta name="title" content="Function Reference · Euler1D"/><meta property="og:title" content="Function Reference · Euler1D"/><meta property="twitter:title" content="Function Reference · Euler1D"/><meta name="description" content="Documentation for Euler1D."/><meta property="og:description" content="Documentation for Euler1D."/><meta property="twitter:description" content="Documentation for Euler1D."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Euler1D</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Euler1D</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../Methodology/">Methodology</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#Problem-Configuration"><span>Problem Configuration</span></a></li><li><a class="tocitem" href="#Timestepping"><span>Timestepping</span></a></li><li><a class="tocitem" href="#Equation-of-State"><span>Equation of State</span></a></li><li><a class="tocitem" href="#Artificial-Dissipation"><span>Artificial Dissipation</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Governing-Equations"><span>Governing Equations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl/blob/main/docs/src/FunctionReference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-Reference"><a class="docs-heading-anchor" href="#Function-Reference">Function Reference</a><a id="Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Reference" title="Permalink"></a></h1><h2 id="Problem-Configuration"><a class="docs-heading-anchor" href="#Problem-Configuration">Problem Configuration</a><a id="Problem-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Configuration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.DefaultSimulationParameters" href="#Euler1D.DefaultSimulationParameters"><code>Euler1D.DefaultSimulationParameters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DefaultSimulationParameters()</code></pre><p>Return a set of default parameters for a simulation.</p><p><strong>Returns</strong></p><p>A <code>Dict{String, Any}</code> with default parameters for a simulation. </p><p><strong>Notes</strong></p><ul><li>Keys with a value of <code>nothing</code> must be set before using this dictionary to initialize a simulation. This is done instead of providing a default function to avoid the possibility of accidentally initializing a simulation with unintended initial conditions.</li></ul><p><strong>Parameters</strong></p><ul><li><code>start_time</code>: The initial time of the simulation. (Unit: s; Default: 0.0)</li><li><code>end_time</code>: The final time of the simulation. (Unit: s; Default: 1.0)</li><li><code>start_position</code>: The position of the left side of the domain. (Unit: m; Default: 0.0)</li><li><code>end_position</code>: The position of the right side of the domain. (Unit: m; Default: 1.0)</li><li><code>number_of_zones</code>: The number of zones to divide the domain into. (Unit: ⋅; Default: 1000)</li><li><code>CFL</code>: The CFL number to use. (Unit: ⋅; Default: 0.2)</li><li><code>artificial_viscosity_coefficient</code>: The coefficient to use for artificial viscosity. (Unit: ⋅; Default: 1e0)</li><li><code>artificial_conductivity_coefficient</code>: The coefficient to use for artificial conductivity. (Unit: ⋅; Default: 1e-2)</li><li><code>min_timestep</code>: The minimum allowable timestep size. Simulation will halt if timestep falls below this value. (Unit: s; Default: 1e-7)</li><li><code>max_cycles</code>: The maximum number of cycles to perform. Simulation will halt if more than this many timesteps are taken. (Unit: ⋅; Default: 1e6)</li><li><code>init_density_function</code>: A <code>Function</code> that returns the initial density as a function of position <code>x</code>. (Unit: kg/m³; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_velocity_function</code>: A <code>Function</code> that returns the initial velocity as a function of position <code>x</code>. (Unit: m/s; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_pressure_function</code>: A <code>Function</code> that returns the initial pressure as a function of position <code>x</code>. (Unit: N/m²; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_gamma_function</code>: A <code>Function</code> that returns the ratio of specific heats as a function of position <code>x</code>. (Unit: ⋅; Default: <code>nothing</code>, must be user-supplied)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Configuration.jl#L150-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.InitializeSimulation" href="#Euler1D.InitializeSimulation"><code>Euler1D.InitializeSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InitializeSimulation( parameters::Dict{String, Any} )</code></pre><p>Initialize a simulation with the parameters provided by <code>parameters</code>. A default set of <code>parameters</code> can be returned from the <a href="#Euler1D.DefaultSimulationParameters"><code>DefaultSimulationParameters()</code></a> function.</p><p><strong>Returns</strong></p><p>A struct of type <code>Simulation{T}</code> that describes the current simulation state. The type <code>T</code> is determined by the type of the members of <code>parameters</code>.</p><p><strong>Notes</strong></p><ul><li>This function performs some basic sanity checking on input parameters such as ensuring that <code>end_time &gt; start_time</code> or <code>end_position &gt; start_position</code>, and will raise an error if any of these checks fail.</li><li>A warning will be raised if any keys in the dictionary are unused, but this will not halt execution.</li><li>This function will not warn about any potential issues with problem configuration or potential stability issues.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Configuration.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.UpdateSimulationState!" href="#Euler1D.UpdateSimulationState!"><code>Euler1D.UpdateSimulationState!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UpdateSimulationState!( state::Simulation{T}, gamma::Function, density::Function, velocity::Function, pressure::Function ) where { T &lt;: AbstractFloat }</code></pre><p>Update the simulation state using the supplied functions to define a new state. See Notes for information about the expected signature of the functions.</p><p><strong>Returns</strong></p><p><code>nothing</code>. Updates the <code>state</code> input in-place.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <code>Simulation{T}</code> representing the simulation state to be updated</li><li><code>gamma</code>: A <code>Function</code> that returns the new values of the ratio of specific heats, gamma</li><li><code>density</code>: A <code>Function</code> that returns the new values of the density</li><li><code>velocity</code>: A <code>Function</code> that returns the new values of velocity</li><li><code>pressure</code>: A <code>Function</code> that returns the new values of pressure</li></ul><p><strong>Notes</strong></p><p>Unlike the functions used in initial problem setup, the functions supplied to <code>UpdateSimulationState</code> have a slightly different expected signature of     ExampleFunction( x::T, oldValue::T ) where { T &lt;: AbstractFloat } where <code>oldValue</code> will be the current value of the state variable at current position <code>x</code> (e.g., the previous value of pressure).</p><p><strong>Side Effects</strong></p><ul><li>Updates the values stored in the vectors for <code>state.gamma</code>, <code>state.mass</code>, <code>state.velocity</code>, <code>state.intenergy</code>, and fields derived from the equation of state in-place.</li></ul><div class="admonition is-warning" id="Warning-7996f190097fcb0f"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-7996f190097fcb0f" title="Permalink"></a></header><div class="admonition-body"><p>If the <code>density</code> function alters the <code>state.density</code> field (that is, it does not just return <code>oldValue</code>), mass will be added or removed from a given zone to achieve a specified value of <code>density</code> without changing zone size. As a consequence, mass will not be conserved in the system in this case.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Configuration.jl#L114-L139">source</a></section></article><h2 id="Timestepping"><a class="docs-heading-anchor" href="#Timestepping">Timestepping</a><a id="Timestepping-1"></a><a class="docs-heading-anchor-permalink" href="#Timestepping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceToTime" href="#Euler1D.AdvanceToTime"><code>Euler1D.AdvanceToTime</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceToTime( state::Simulation{T}, stoptime::T, Δt::T; exact::Bool=false ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation with initial state <code>state</code> to a time specified by <code>stoptime</code> with a fixed timestep. </p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the final cycle.</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>stoptime</code>: The time to advance to. (Unit: s)</li><li><code>Δt</code>: The timestep size. (Unit: s)</li><li><code>exact</code>: If true, try to stop as close as possible to <code>stoptime</code> by adjusting the final timestep size (Default: <code>false</code>)</li></ul><p><strong>Notes</strong></p><ul><li>The current simulation time is determined by the <code>Simulation</code> field <code>state.time</code>. If <code>state.time &gt; stoptime</code>, no steps will be taken.</li><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function simply calls <code>AdvanceOneCycle!</code> repeatedly until the simulation time reaches <code>stoptime</code>. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> or <a href="#Euler1D.AdvanceNCycles"><code>AdvanceNCycles()</code></a> is that various backing arrays are pre-allocated to improve speed.</li><li>If <code>exact=true</code>, the timestep of the final cycle is adjusted so that the time of the final state is as close as possible to <code>stoptime</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L1-L20">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceToTime( state::Simulation{T}, stoptime::T; exact::Bool=false ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation with initial state <code>state</code> to a time specified by <code>stoptime</code> with a variable timestep. </p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the final cycle</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>stoptime</code>: The time to advance to. (Unit: s)</li><li><code>exact</code>: If true, try to stop as close as possible to <code>stoptime</code> by adjusting the final timestep size (Default: false)</li></ul><p><strong>Notes</strong></p><ul><li>The current simulation time is determined by the <code>Simulation</code> field <code>state.time</code>. If <code>state.time &gt; stoptime</code>, no steps will be taken.</li><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function simply calls <code>AdvanceOneCycle!()</code> repeatedly until the simulation time reaches <code>stoptime</code>. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> or <a href="#Euler1D.AdvanceNCycles"><code>AdvanceNCycles()</code></a> is that various backing arrays are pre-allocated to improve speed.</li><li>The timestep size, Δt, is determined for each cycle based on the minimum time for an acoustic wave to traverse a zone. See the documentation for <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details. </li><li>If <code>exact=true</code>, the timestep of the final cycle is adjusted so that the time of the final state is as close as possible to <code>stoptime</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceOneCycle" href="#Euler1D.AdvanceOneCycle"><code>Euler1D.AdvanceOneCycle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceOneCycle( state::Simulation{T}, Δt::T ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle with a timestep of Δt.</p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the cycle</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the cycle.</li><li><code>Δt</code>: The size of the time step. (Unit: s)</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates a <code>deepcopy()</code> of the input state. The copy is modified and returned from this function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L122-L136">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceOneCycle( state::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle. </p><p><strong>Returns</strong></p><ul><li>A <code>Simulation{T}</code> representing the state at the end of the cycle</li></ul><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the cycle</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates a <code>deepcopy()</code> of the input state and returns the copy.</li><li>The timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceOneCycle!" href="#Euler1D.AdvanceOneCycle!"><code>Euler1D.AdvanceOneCycle!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceOneCycle!( output::Simulation{T}, input::Simulation{T}, Δt::T ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle with a timestep of Δt.</p><p><strong>Returns</strong></p><p><code>nothing</code>. Modifies <code>output</code> in-place.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: A <code>Simulation{T}</code> that will represent the output state. This will be modified by the function to represent the simulation state after advancing one cycle.</li><li><code>input</code>: A <code>Simulation{T}</code> that represents the simulation state at the start of the cycle.</li><li><code>Δt</code>: The size of the time step. (Unit: s)</li></ul><p><strong>Side Effects</strong></p><ul><li>All fields of <code>output</code> are modified in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L79-L94">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceOneCycle!( output::Simulation{T}, input::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle. </p><p><strong>Returns</strong></p><p><code>nothing</code>. Modifies <code>output</code> in-place.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: A <code>Simulation{T}</code> that will represent the output state. This will be modified by the function to represent the simulation state after advancing one cycle.</li><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the cycle</li></ul><p><strong>Notes</strong></p><ul><li>The timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul><p><strong>Side Effects</strong></p><ul><li>All fields of <code>output</code> are modified in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L99-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceNCycles" href="#Euler1D.AdvanceNCycles"><code>Euler1D.AdvanceNCycles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceNCycles( state::Simulation{T}, ncycles::UInt, Δt::T ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by <code>ncycles</code> cycles with a fixed timestep.</p><p><strong>Returns</strong></p><ul><li>A <code>Simulation{T}</code> representing the state at the end of the final cycle</li></ul><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>ncycles</code>: The number of cycles to advance.</li><li><code>Δt</code>: The size of the time step. (Unit: s)</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function calls <a href="#Euler1D.AdvanceOneCycle!"><code>AdvanceOneCycle!()</code></a> a total of <code>ncycles</code> times to advance the simulation. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> if the number of cycles to advance is known is that various backing arrays are pre-allocated to improve speed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L164-L180">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceNCycles( state::Simulation{T}, ncycles::UInt ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by <code>ncycles</code> cycles with a variable timestep. </p><p><strong>Returns</strong></p><ul><li>A <code>Simulation{T}</code> representing the state at the end of the final cycle</li></ul><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>ncycles</code>: The number of cycles to advance. (Unit: ⋅)</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function calls <a href="#Euler1D.AdvanceOneCycle!"><code>AdvanceOneCycle!()</code></a> a total of <code>ncycles</code> times to advance the simulation. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> if the number of cycles to advance is known is that various backing arrays are pre-allocated to improve speed.</li><li>The timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L197-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.CalculateTimestepSize" href="#Euler1D.CalculateTimestepSize"><code>Euler1D.CalculateTimestepSize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CalculateTimestepSize( state::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an automatic timestep size for the next simulation cycle based on the current simulation state. See the Notes section for details on how the timestep is determined.</p><p><strong>Returns</strong></p><ul><li>A scalar of type <code>T</code> representing the timestep size for the next cycle based on the current simulation state.</li></ul><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <code>Simulation{T}</code> representing the problem state.</li></ul><p><strong>Notes</strong></p><ul><li>For each zone, the local speed of sound is computed according to <code>c = √( γ P / ρ )</code>, where γ, P, and ρ are the ratio of specific heats, the pressure, and the density of the gas in that zone.</li><li>The time for an acoustic wave to traverse a zone with length <code>Δx</code> is computed as <code>t = Δx / c</code>.</li><li>The minimum traversal time for all zones is multiplied by the user-specified CFL number to obtain the timestep size.</li><li>Sanity checking for negative zone sizes and small timesteps is performed to detect problem instability.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Timestepping.jl#L232-L248">source</a></section></article><h2 id="Equation-of-State"><a class="docs-heading-anchor" href="#Equation-of-State">Equation of State</a><a id="Equation-of-State-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-of-State" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.EOS_Density" href="#Euler1D.EOS_Density"><code>Euler1D.EOS_Density</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EOS_Density( mass::T, Δx::T ) where { T &lt;: AbstractFloat } = mass / Δx</code></pre><p>Compute the density of the fluid in a zone.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the density of a zone.</p><p><strong>Arguments</strong></p><ul><li><code>mass</code>: The total mass contained within the zone. (Unit: kg)</li><li><code>Δx</code>: The size of the zone. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>Density is calculated as:</p><pre><code class="nohighlight hljs">ρ = mass / Δx</code></pre><p>As this is the physical definition of density, this calculation does not assume any particular equation of state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/EquationOfState.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.EOS_Pressure" href="#Euler1D.EOS_Pressure"><code>Euler1D.EOS_Pressure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EOS_Pressure( γ::T, ρ::T, e::T ) where { T &lt;: AbstractFloat }
EOS_Pressure( γ::T, mass::T, Δx::T, e::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the pressure of a zone using an ideal gas equation of state.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the pressure within the zone.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: The ratio of specific heats of the fluid in the zone. (Unit: ⋅)</li><li><code>ρ</code>: The density of the zone. (Unit: kg/m³)</li><li><code>mass</code>: The total mass contained within the zone. (Unit: kg)</li><li><code>Δx</code>: The size of the zone. (Unit: m)</li><li><code>e</code>: The internal energy per unit mass of the zone. (Unit: m²/s²)</li></ul><p><strong>Notes</strong></p><p>The pressure is calculated as:</p><pre><code class="nohighlight hljs">P = ( γ - 1 ) ⋅ ρ ⋅ e</code></pre><p>The four-parameter version of this function computes density using <a href="#Euler1D.EOS_Density"><code>EOS_Density()</code></a>. See the documentation for that function for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/EquationOfState.jl#L45-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.EOS_SpeedOfSound" href="#Euler1D.EOS_SpeedOfSound"><code>Euler1D.EOS_SpeedOfSound</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EOS_SpeedOfSound( γ::T, P::T, ρ::T ) where { T &lt;: AbstractFloat }
EOS_SpeedOfSound( γ::T, e::T, mass::T, Δx::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the speed of sound in a zone using an ideal gas equation of state.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the speed of sound in the zone.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: The ratio of specific heats in the zone. (Unit: ⋅)</li><li><code>e</code>: The internal energy per unit mass in the zone. (Unit: m²/s²)</li><li><code>P</code>: The pressure in the zone. (Unit: kg/(m⋅s²))</li><li><code>ρ</code>: The density of the fluid in the zone. (Unit: kg/m³)</li><li><code>mass</code>: The mass contained in the zone. (Unit: kg)</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>The speed of sound is calculated as:</p><pre><code class="nohighlight hljs">c = √( γ * P / ρ )</code></pre><p>The four-parameter version of this function computes density using <a href="#Euler1D.EOS_Density"><code>EOS_Density()</code></a> and pressure using <a href="#Euler1D.EOS_Pressure"><code>EOS_Pressure()</code></a>. See the documentation of those functions for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/EquationOfState.jl#L94-L117">source</a></section></article><h2 id="Artificial-Dissipation"><a class="docs-heading-anchor" href="#Artificial-Dissipation">Artificial Dissipation</a><a id="Artificial-Dissipation-1"></a><a class="docs-heading-anchor-permalink" href="#Artificial-Dissipation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.artificial_viscosity" href="#Euler1D.artificial_viscosity"><code>Euler1D.artificial_viscosity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">artificial_viscosity( Cᵥ::T, c::T, ρ::T, Δx::T, u₋::T, u₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an artificial viscosity within a zone. </p><p><strong>Returns</strong></p><p>A value of type <code>T</code> representing the value of the artificial viscosity.</p><p><strong>Arguments</strong></p><ul><li><code>Cᵥ</code>: An O(1) coefficient to control the strength of the artificial viscosity. (Unit: ⋅)</li><li><code>c</code>: The speed of sound in the zone. (Unit: m/s)</li><li><code>ρ</code>: The density of the zone. (Unit: kg/m³)</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li><li><code>u</code>: The velocity of the zone boundaries, with superscripts - and + referring to the left and right boundaries of the zone, respectively. (Unit: m/s)</li></ul><p><strong>Notes</strong></p><ul><li>This artificial viscosity is based on the method described by Wilkins (1980), which in turn relies upon the methods of Von Neumann and Richtmyer (1950) and Landschoff (1955). The values computed by this function should be added to the pressure field during governing equation updates.</li><li>This function returns zero if <code>∂u/∂x &gt; 0</code>, which will be the case for regions where the flow is expanding. This is done to restrict artificial viscosity only to regions of compression.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/ArtificialDissipation.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.artificial_conductivity" href="#Euler1D.artificial_conductivity"><code>Euler1D.artificial_conductivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">artificial_conductivity( Cₖ::T, u::T, c₋::T, e₋::T, Δx₋::T, c₊::T, e₊::T, Δx₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an artificial flux of internal energy across a zone interface.</p><p><strong>Returns</strong></p><p>A value of type <code>T</code> representing the artifical flux of internal energy across a zone boundary.</p><p><strong>Arguments</strong></p><ul><li><code>Cₖ</code>: An O(1) coefficient to control the strength of the artificial conductivity. (Unit: ⋅)</li><li><code>u</code>: The velocity of the zone interface. (Unit: m/s)</li><li><code>c</code>: The speed of sound, where superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m/s)</li><li><code>e</code>: The internal energy per unit mass. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m²/s²)</li><li><code>Δx</code>: Length of the zone. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>The artificial conductivity is modeled as a Fickian diffusivity. That is, the flux of energy across a zone boundary, fₑ, is described by</p><pre><code class="nohighlight hljs">fₑ = -κ ∂e/∂x</code></pre><p>where e is the internal energy per unit mass and κ is the (artificial) conductivity coefficient. The gradient of internal energy is treated with a simple forward finite difference. The artificial conductivity coefficient is modeled as</p><pre><code class="nohighlight hljs">κ = Cₖ * cₘ * Δx</code></pre><p>where</p><ul><li><code>Cₖ</code> an O(1) coefficient.</li><li><code>cₘ</code>  is a characteristic velocity taken to be max(c̄±u, c̄), where c̄=0.5*(c₋+c₊) is the average speed of sound of the two adjacent zones and u is the velocity of the zone interface. </li><li><code>Δx</code> is the distance between the zone centers</li></ul><p>By convention, this leads to a positive flux if energy is diffusing in the positive x direction, and negative if it is diffusing in the negative x direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/ArtificialDissipation.jl#L53-L84">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Simulation" href="#Euler1D.Simulation"><code>Euler1D.Simulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Simulation{T}</code></pre><p>A structure containing all the internal variables and arrays used in the simulation.</p><p><strong>Parameters</strong></p><ul><li><code>nzones::Int</code>: The number of zones in the simulation. (Unit: ⋅)</li><li><code>nedges::Int</code>: The number of zone edges in the simulation, equal to <code>nzones + 1</code>. (Unit: ⋅)</li><li><code>CFL::Float64</code>: The CFL number to be used when calculating timesteps. (Unit: ⋅)</li><li><code>start_time::Float64</code>: The initial time of the simulation. (Unit: s)</li><li><code>viscosity_coefficient::Float64</code>: The coefficient used to scale artificial viscosity. (Unit: ⋅)</li><li><code>conductivity_coefficient::Float64</code>: The coefficient used to scale artificial conductivity. (Unit: ⋅)</li><li><code>time::Base.RefValue{T}</code>: The current time of the simulation. (Unit: s)</li><li><code>dt::Base.RefValue{T}</code>: The size of the timestep taken in the last cycle. (Unit: s)</li><li><code>cycles::Base.RefValue{UInt}</code>: The number of cycles performed so far. (Unit: ⋅)</li><li><code>min_dt::Float64</code>: The minimum allowable timestep size. Simulation will halt if <code>Δt</code> falls below this value. (Unit: s)</li><li><code>max_cycles::UInt</code>: The maximum number of cycles to perform. Simulation will halt if <code>cycles</code> exceeds this value. (Unit: ⋅)</li><li><code>zone_edge::Vector{T}</code>: A vector of locations of zone edges. Increases monotonically. (Unit: m)</li><li><code>zone_center::Vector{T}</code>: A vector of locations of zone centers, defined as the midpoint between two zone edges. Increases monotonically. (Unit: m)</li><li><code>zone_length::Vector{T}</code>: A vector of the length of each zone. (Unit: m)</li><li><code>gamma::Vector{T}</code>: A vector of the ratio of specific heats inside each zone. (Unit: ⋅)</li><li><code>mass::Vector{T}</code>: A vector of the mass contained within each zone. Assumed constant. (Unit: kg)</li><li><code>density::Vector{T}</code>: A vector of the density of the fluid within each zone. Computed using the equation of state as mass/Δx. (Unit: kg/m³)</li><li><code>velocity::Vector{T}</code>: A vector of velocities of zone edges. (Unit: m/s)</li><li><code>pressure::Vector{T}</code>: A vector of pressures inside each zone. Computed from the equation of state. (Unit: kg/(m⋅s²))</li><li><code>intenergy::Vector{T}</code>: A vector of the internal energy per unit mass of each zone. (Unit: m²/s²)</li><li><code>speedofsound::Vector{T}</code>: A vector of the speed of sound within each zone. Computed from the equation of state. (Unit: m/s)</li><li><code>viscosity::Vector{T}</code>: A vector of the artificial viscosity within each zone, added to the pressure field. See ArtificialDissipation.jl for more information. (Unit: kg/(m⋅s²))</li><li><code>energy_flux::Vector{T}</code>: A vector of fluxes of internal energy per unit mass across each zone boundary. Added to the energy equation as a diffusion term. See ArtificialDissipation.jl for more information. (Unit: m³/s³)</li><li><code>momentum_rhs::Vector{T}</code>: A vector of the right hand side of the momentum equation at each zone edge. (Unit: m/s²)</li><li><code>energy_rhs::Vector{T}</code>: A vector of the right hand side of the energy equation within each zone. (Unit: m²/s³)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/Types.jl#L1-L32">source</a></section></article><h2 id="Governing-Equations"><a class="docs-heading-anchor" href="#Governing-Equations">Governing Equations</a><a id="Governing-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Governing-Equations" title="Permalink"></a></h2><div class="admonition is-info" id="Note-adaf0bef1046c13b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-adaf0bef1046c13b" title="Permalink"></a></header><div class="admonition-body"><p>These functions are not intended to be called directly as part of simulation setup. However, as their functionality is central to this package, they are documented here for reference.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Momentum" href="#Euler1D.Momentum"><code>Euler1D.Momentum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Momentum( m₋::T, P₋::T, m₊::T, P₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the momentum equation at a zone interface. See the Notes section for information on the equation being solved.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the rate of change of velocity of a zone interface over time.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The mass of the zone. (Unit: kg)</li><li><code>P</code>: The pressure of the zone (Unit: kg/(m⋅s²))</li></ul><p>For each of these parameters, a - subscript refers to the zone to the left of the zone interface and a + subscript refers to the zone to the right of the zone interface.</p><p><strong>Notes</strong></p><p>The governing equation solved in this function is:     ∂u/∂t = (1/ρ₀) * ∂P/∂x Through the numerical disretization, this reduces to     ∂u/∂t = 1/m̄ ( P₊ - P₋ ) If using artificial viscosity per the method of Von Neumann and Richtmyer (1950), the artificial viscosity term should be added to the pressure field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/EulerEquations.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Energy" href="#Euler1D.Energy"><code>Euler1D.Energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Energy( ρ::T, P::T, Δx::T, u₋::T, u₊::T, q₋::T, q₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the energy equation in a zone. See the Notes section for the specific equations that are solved.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the rate of change of internal energy inside the zone.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The mass of the zone. (Unit: kg)</li><li><code>P</code>: The pressure of the zone. (Unit: kg/(m⋅s²))</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li><li><code>u</code>: The velocity of the zone edges on the (-): left and (+): right of the zone. (Unit: m/s)</li><li><code>q</code>: The (artificial) flux of internal energy across the (-): left and (+): right zone edges. (Unit: m³/s³) </li></ul><p><strong>Notes:</strong></p><p>The governing equation solved in this function is     ∂e/∂t = - ( P / ρ₀ ) * ∂u/∂x + ∑q Through discretization, this becomes     ∂eᵢ/∂t = - ( Pᵢ / mᵢ ) * ( u₊ - u₋ ) + ∑q </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/4df13bcd3b838c7734325f0393dc766010e0c1e3/src/EulerEquations.jl#L52-L72">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Methodology/">« Methodology</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 4 August 2025 19:07">Monday 4 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
