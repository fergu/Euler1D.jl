<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Euler1D</title><meta name="title" content="Examples · Euler1D"/><meta property="og:title" content="Examples · Euler1D"/><meta property="twitter:title" content="Examples · Euler1D"/><meta name="description" content="Documentation for Euler1D."/><meta property="og:description" content="Documentation for Euler1D."/><meta property="twitter:description" content="Documentation for Euler1D."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Euler1D</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Euler1D</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Sod-Shock-Tube"><span>Sod Shock Tube</span></a></li><li><a class="tocitem" href="#Plotting-Results"><span>Plotting Results</span></a></li><li><a class="tocitem" href="#Modifying-Problem-State"><span>Modifying Problem State</span></a></li></ul></li><li><a class="tocitem" href="../Methodology/">Methodology</a></li><li><a class="tocitem" href="../FunctionReference/">Function Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl/blob/main/docs/src/Examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Sod-Shock-Tube"><a class="docs-heading-anchor" href="#Sod-Shock-Tube">Sod Shock Tube</a><a id="Sod-Shock-Tube-1"></a><a class="docs-heading-anchor-permalink" href="#Sod-Shock-Tube" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Sod_shock_tube">Sod shock tube</a> is a case involving a rightwards travelling shock wave and a leftwards travelling expansion wave. Its initial condition is given by:</p><p class="math-container">\[\left(
\begin{aligned}
\rho_L \\
P_L \\
u_L
\end{aligned}
\right) =
\left(
\begin{aligned}
1.0 \\
1.0 \\
0.0
\end{aligned}
\right),~
\left(
\begin{aligned}
\rho_R \\
P_R \\
u_R
\end{aligned}
\right) =
\left(
\begin{aligned}
0.125 \\
0.1 \\
0.0
\end{aligned}
\right)\]</p><p>where <span>$\rho$</span>, <span>$P$</span>, and <span>$u$</span> are the density, pressure, and velocity, the domain is in the range <span>$x=[0,1]$</span>, and the subscripts <code>L</code> and <code>R</code> refer to states to the left and right of an interface initially located at <span>$x=0.5$</span>. While an exact solution for this configuration can be found, this example will focus on setting up an <code>Euler1D</code> simulation to simulate the Sod shock tube.</p><p>A simulation is initialized using a set of dictionary key:value pairs describing various aspects of the simulation, including the functions used to describe the initial profiles of density, velocity, pressure, and the ratio of specific heats. A default set of parameters can be obtained using the function [<code>DefaultSimulationParameters()</code>][@ref]:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Euler1D</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters = DefaultSimulationParameters()</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Any} with 14 entries:
  &quot;artificial_conductivity_coefficient&quot; =&gt; 0.01
  &quot;end_time&quot;                            =&gt; 1.0
  &quot;init_pressure_function&quot;              =&gt; nothing
  &quot;artificial_viscosity_coefficient&quot;    =&gt; 1.0
  &quot;init_gamma_function&quot;                 =&gt; nothing
  &quot;number_of_zones&quot;                     =&gt; 1000
  &quot;end_position&quot;                        =&gt; 1.0
  &quot;maximum_cycles&quot;                      =&gt; 1.0e6
  &quot;start_position&quot;                      =&gt; 0.0
  &quot;start_time&quot;                          =&gt; 0.0
  &quot;init_velocity_function&quot;              =&gt; nothing
  &quot;CFL&quot;                                 =&gt; 0.2
  &quot;minimum_timestep&quot;                    =&gt; 1.0e-7
  &quot;init_density_function&quot;               =&gt; nothing</code></pre><p>You may notice that there are several parameters with a value of <code>nothing</code>. These must be supplied before the simulation can be initialized since it is difficult to make reasonable default assumptions. Of particular note are the keys <code>init_density_function</code>, <code>init_velocity_function</code>, <code>init_pressure_function</code>, and <code>init_gamma_function</code>. These refer to functions that describe the inital profiles of density, velocity, pressure, and the ratio of specific heats, respectively. A set of functions to implement the Sod shock tube initial conditions looks like:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_density( x )
           if ( x &lt; 0.5 )
               return 1.0
           else
               return 0.125
           end
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_velocity( x )
           return 0.0
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_pressure( x )
           if ( x &lt; 0.5 )
               return 1.0
           else
               return 0.1
           end
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_gamma( x )
           return 1.4
       end;</code></pre><div class="admonition is-category-caution" id="Caution-94d11464eb28ac1e"><header class="admonition-header">Caution<a class="admonition-anchor" href="#Caution-94d11464eb28ac1e" title="Permalink"></a></header><div class="admonition-body"><p>The <code>x</code> argument in these functions is the location of where a given variable will be stored. Due to the fact that some variables are zone-centered while others are edge-centered, it should not be assumed that <code>x</code> will have the same value in all functions. Additionally, due to how Julia performs vectorized computations, these functions should not assume anything about the order in which they are executed. i.e., that the <code>n</code>-th function call will always have a certain value of <code>x</code>.</p></div></div><p>The <code>simulation_parameters</code> dictionary can now be modified to describe the desired initial condition. In this case, this would look like:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_density_function&quot;] = init_density;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_velocity_function&quot;] = init_velocity;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_pressure_function&quot;] = init_pressure;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_gamma_function&quot;] = init_gamma;</code></pre><p>The <code>simulation_parameters</code> dictionary has many other keys that can be modified. See <a href="../FunctionReference/#Euler1D.DefaultSimulationParameters"><code>DefaultSimulationParameters()</code></a> for a list of parameters that can be set.</p><p>Once all desired parameters have been set, the simulation can be initialized:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_state = InitializeSimulation( simulation_parameters )</code><code class="nohighlight hljs ansi" style="display:block;">Euler1D simulation
	Start time: 0.0
	Current time: 0.0
	Final time: 1.0
	Last Δt: 1.0e-7 (Min: 1.0e-7)
	Cycle count: 0 (Max: 1000000)
	CFL number: 0.2
	Number of zones: 1000
	Available fields: nzones, nedges, CFL, t₀, t₁, Cᵥ, Cₖ, time, Δt, cycles, min_Δt, max_cycles, zone_edge, zone_center, zone_length, gamma, mass, density, velocity, pressure, intenergy, speedofsound, viscosity, energy_flux, ∂u∂t, ∂e∂t</code></pre><p>The <code>init_state</code> variable is a <a href="../FunctionReference/#Euler1D.Simulation"><code>Simulation</code></a> type that holds information about the simulation. </p><div class="admonition is-info" id="Note-d977cff34a79d5a2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d977cff34a79d5a2" title="Permalink"></a></header><div class="admonition-body"><p>The functions that describe the initial conditions are not called until <a href="../FunctionReference/#Euler1D.InitializeSimulation"><code>InitializeSimulation()</code></a> is called, at which time they are called at every point in the domain. For these reasons, it is good to be sure that the functions are not computationally heavy.</p></div></div><p>A common time to examine the Sod shock tube solution is <code>t=0.1</code>. The <a href="../FunctionReference/#Euler1D.AdvanceToTime"><code>AdvanceToTime()</code></a> function can be used to advance the simulation to this time:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; end_state = AdvanceToTime( init_state, 0.1; exact=true )</code></pre><p>where <code>0.1</code> is the time to advance to and the <code>exact=true</code> keyword tells the simulation to modify the final time step to stop as close as possible to the final time. If <code>exact=false</code> were supplied instead (or if the <code>exact</code> argument was omitted), the simulation would stop as soon as the current time is greater than the specified stopping time, but no modification of the timestep would be made and so the actual stopping time may differ from the specified stopping time. The size of the difference will depend on the timestep size.</p><div class="admonition is-success" id="Tip-316815364160d435"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-316815364160d435" title="Permalink"></a></header><div class="admonition-body"><p>This example wrote out the functions used for initial conditions in full for instructive purposes. However, there is no requirement that the functions be defined in this way. For example, for simple initial conditions, a function could be defined using <a href="https://docs.julialang.org/en/v1/manual/control-flow/">ternary operators</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_density( x ) = x &lt; 0.5 ? 1.0 : 0.125; # A function that varies in space</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_gamma( x ) = 1.4; # A function with a constant value</code></pre><p>or even using <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions">anonymous functions</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_density_function&quot;] = (x) -&gt; x &lt; 0.5 ? 1.0 : 0.125; # A function that varies in space</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_gamma_function&quot;] = (x) -&gt; 1.4; # A function with a constant value</code></pre><p>There is no requirement or advantage to using one method over any other. These are simply alternative ways of defining a function to describe the initial condition.</p></div></div><h2 id="Plotting-Results"><a class="docs-heading-anchor" href="#Plotting-Results">Plotting Results</a><a id="Plotting-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Results" title="Permalink"></a></h2><p>This section outlines a few examples of how simulation data can be post-processed to visualize results or perform advanced processing.</p><div class="admonition is-info" id="Note-1dcd9ffcf57d018a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1dcd9ffcf57d018a" title="Permalink"></a></header><div class="admonition-body"><p>There are numerous packages in the Julia ecosystem to handle plotting (e.g. <a href="https://docs.juliaplots.org/stable/">Plots.jl</a>, <a href="https://docs.makie.org/stable/">Makie.jl</a>), writing to disk (e.g. <a href="https://csv.juliadata.org/stable/">CSV.jl</a>, <a href="https://dataframes.juliadata.org/stable/">DataFrames.jl</a>, <a href="https://juliaio.github.io/HDF5.jl/stable/">HDF5.jl</a>), and any other data analysis routine that might be desired. The people developing these packages (and others like them) are immensely talented, and one would be well-advised to utilize their hard work if a package with suitable functionality exists.  For this reason, this package actively avoids making assumptions about what a user will want to do with the simulation data after the simulation is complete. This means that there is no built-in functionality to plot simulation data, write it to disk, or perform any other sort of postprocessing. Instead, all simulation outputs are simply elementary Julia types (e.g. <code>Vector{Float64}</code>), and can be manipulated using the usual built-in Julia methods, or by using any suitable package that provides the required functionality. </p></div></div><h3 id="Line-Plot"><a class="docs-heading-anchor" href="#Line-Plot">Line Plot</a><a id="Line-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Line-Plot" title="Permalink"></a></h3><p>The simplest case of post-processing data is to just plot profiles of the solution state at the final time in the simulation. Fortunately, all necessary fields can be obtained from the <code>Simulation</code> variable in the form of elementary Julia types. For example, to plot the profile of density from the simulation performed in <a href="#Sod-Shock-Tube">Sod Shock Tube</a> using the <a href="https://docs.juliaplots.org/stable/">Plots.jl</a> library, one can do</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot( end_state.zone_center, end_state.density );</code></pre><p><img src="../sod_density.svg" alt/> Similar plots can be made for other zone-centered quantities such as internal energy or pressure. </p><div class="admonition is-success" id="Tip-4663511ef051e0eb"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-4663511ef051e0eb" title="Permalink"></a></header><div class="admonition-body"><p>If plotting edge-centered quantities such as velocity, the <code>end_state.zone_edge</code> variable should be used for the spatial coordinate.</p></div></div><h3 id="X-T-diagrams"><a class="docs-heading-anchor" href="#X-T-diagrams">X-T diagrams</a><a id="X-T-diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#X-T-diagrams" title="Permalink"></a></h3><p>It is often useful to look at the evolution of the problem solution as a function of space and time rather than at just a single time instant. X-T diagrams are a useful way to perform this visualization. Gathering the data required to generate this type of plot is a little bit more complicated than the previous examples, however.</p><p>The simulation can be set up identically to previous examples: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters = DefaultSimulationParameters();
       # We&#39;ll define our initialization functions using anonymous functions to keep things short</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_density_function&quot;] = (x) -&gt; x &lt; 0.5 ? 1.0 : 0.125;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_velocity_function&quot;] = (x) -&gt; 0.0;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_pressure_function&quot;] = (x) -&gt; x &lt; 0.5 ? 1.0 : 0.1;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_gamma_function&quot;] = (x) -&gt; 1.4;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_state = InitializeSimulation( simulation_parameters )</code></pre><p>In order to generate an X-T diagram, we will need to record the simulation state at multiple times in the simulation. To do this, let&#39;s define a new function that will be responsible for advancing the simulation through time: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Interpolations</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function run_simulation( init_state::Simulation{T}, end_time::T ) where { T &lt;: AbstractFloat }
           new_state = deepcopy( init_state ) # We&#39;ll need a copy of our initial state to modify inside the while loop
           # Information about plotting
           plot_dt = 0.001 # How often to stop and record data
           next_plot = 0.0 # The next time to stop and record data
           # Set up some matricies to hold our plotting data
           plot_times = zeros( 0 ) # The times at which we&#39;ve recorded data
           plot_positions = init_state.zone_center # Where to plot the data at in space. We&#39;ll use the initial grid
           plot_J₊ = zeros( 0, init_state.nzones ) # A matrix of the positive Riemann invariant values in every zone in the simulation
           plot_J₋ = zeros( 0, init_state.nzones ) # A matrix of the negative Riemann invariant values at every zone in the simulation
           while ( new_state.time.x &lt;= end_time ) # Keep looping until we&#39;ve reached our end time
               new_state = AdvanceToTime( new_state, next_plot; exact=true ) # Advance the solution to the next time to record data
               # Now record data about the simulation state
               plot_times = vcat( plot_times, new_state.time.x ) # Record our current time, appending it to the plot_times vector
               # Now compute the Riemann invariants.
               # For this we&#39;ll need to interpolate the velocities to zone centers, which we&#39;ll do with a simple average
               uₘ = 0.5 .* ( new_state.velocity[1:end-1] .+ new_state.velocity[2:end] )
               # Now compute the Riemann invariants
               J₊ = uₘ .+ ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Positive Riemann invariant
               J₋ = uₘ .- ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Negative Riemann invariant
               # Most contour plot functions assume data is on a cartesian grid
               # However, because the grid zones in the simulation are moving, we&#39;ll need to interpolate the data back onto a cartesian grid.
               # For simplicity, we will use the initial simulation grid as the grid for plotting
               # We can use Interpolations.jl for this
               J₊_interp = interpolate( ( new_state.zone_center, ), J₊, Gridded(Linear()) ) # Set up a linear interpolation of our data
               J₊_extrap = extrapolate( J₊_interp, Line() ) # Linearly extrapolate if needed.
               plot_J₊ = vcat( plot_J₊, J₊_extrap( plot_positions )&#39; ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data
       
               J₋_interp = interpolate( ( new_state.zone_center, ), J₋, Gridded(Linear()) ) # Set up a linear interpolation of our data
               J₋_extrap = extrapolate( J₋_interp, Line() ) # Linearly extrapolate if needed
               plot_J₋ = vcat( plot_J₋, J₋_extrap( plot_positions )&#39; ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data
               next_plot = next_plot + plot_dt
           end
           # Now that the simulation is done, we can save our plot
           # First compute the minimum and maximum Riemann invariant values. This helps set the contour levels for our plot
           minJ = min( minimum( plot_J₊ ), minimum( plot_J₋ ) )
           maxJ = max( maximum( plot_J₊ ), maximum( plot_J₊ ) )
           # Now plot the Riemann invariants as contours
           p = contour( plot_positions, plot_times, plot_J₊; c=:black, levels=minJ:0.2:maxJ, cbar=false ) # Positive invariants
           contour!( p, plot_positions, plot_times, plot_J₋; c=:black, levels=minJ:0.2:maxJ ) # Negative invariants
           savefig( p, &quot;sod_xt.svg&quot; )
           return new_state
       end;</code></pre><p>There&#39;s a lot going on in this function. Most of it is straightforward and explained in the comments. However, there&#39;s a few things worth highlighting. In particular, X-T diagrams can be made using quantities such as pressure or density, but <a href="https://en.wikipedia.org/wiki/Riemann_invariant">Riemann Invariants</a> are a particularly powerful way to visualize the movement of waves within the domain. The Euler equations have positive and negative Riemann invariants, corresponding to rightwards- and leftwards-moving waves, respectively. These are computed using the following lines:</p><pre><code class="language-julia hljs"># Now compute the Riemann invariants. 
# For this we&#39;ll need to interpolate the velocities to zone centers, which we&#39;ll do with a simple average
uₘ = 0.5 .* ( new_state.velocity[1:end-1] .+ new_state.velocity[2:end] )
# Now compute the Riemann invariants
J₊ = uₘ .+ ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Positive Riemann invariant
J₋ = uₘ .- ( 2.0 .* new_state.speedofsound ) ./ ( new_state.gamma .- 1.0 ) # Negative Riemann invariant</code></pre><p>These lines first translate the velocity (which is edge-centered) to the zone centers, and then uses that average velocity along with the speed of sound and ratio of specific heats to compute the positive and negative Riemann invariants as a function of space.</p><p>Now that we have the Riemann invariants, we need to store them for plotting. However, most contour plotting functions (which we will use to plot our X-T diagram) assume that the data is stored on a rectangular grid. In this context, this would mean that the <code>x</code> positions are the same for all time. However, because this is a Lagrangian code, the <code>x</code> positions of the data are not constant as a function of time, so we need to massage the data into a format the contour plotting function can accept. This is done by interpolating the data at a given time back onto the initial grid using the <code>Interpolations.jl</code> package and the following lines: </p><pre><code class="language-julia hljs">J₊_interp = interpolate( ( new_state.zone_center, ), J₊, Gridded(Linear()) ) # Set up a linear interpolation of our data
J₊_extrap = extrapolate( J₊_interp, Line() ) # Linearly extrapolate if needed.
plot_J₊ = vcat( plot_J₊, J₊_extrap( plot_positions )&#39; ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data
        
J₋_interp = interpolate( ( new_state.zone_center, ), J₋, Gridded(Linear()) ) # Set up a linear interpolation of our data
J₋_extrap = extrapolate( J₋_interp, Line() ) # Linearly extrapolate if needed
plot_J₋ = vcat( plot_J₋, J₋_extrap( plot_positions )&#39; ) # Interpolate the simulation data back onto the initial grid and append it to our matrix of data</code></pre><p>The <code>interpolate</code> and <code>extrapolate</code> functions set up this interpolation, and then the <code>vcat</code> lines actually perform the interpolation and append the result to the matricies we&#39;re using to store our data.</p><p>Now that the simulation is done, we&#39;ll configure the contour plot to actually produce the X-T diagram. First, we want to compute the minimum and maximum values of the Riemann invariants. We do this so that the contour plots for the positive and negative invariants use the same contour levels, which helps make sure lines are connected to each other and aids in visualization.</p><pre><code class="language-julia hljs"># First compute the minimum and maximum Riemann invariant values. This helps set the contour levels for our plot
minJ = min( minimum( plot_J₊ ), minimum( plot_J₋ ) ) 
maxJ = max( maximum( plot_J₊ ), maximum( plot_J₊ ) )</code></pre><p>We can now actually create the contour plot:</p><pre><code class="language-julia hljs"># Now plot the Riemann invariants as contours
p = contour( plot_positions, plot_times, plot_J₊; c=:black, levels=minJ:0.2:maxJ, cbar=false ) # Positive invariants
contour!( p, plot_positions, plot_times, plot_J₋; c=:black, levels=minJ:0.2:maxJ ) # Negative invariants
savefig( p, &quot;sod_xt.svg&quot; )</code></pre><p>These lines are responsible for actually creating the contour plot. The first line plots the positive (rightwards-moving) Riemann invariants, and the second line adds a plot for the negative (leftwards-moving) Riemann invariants. The optional arguments are <code>c</code>, which sets the line color, <code>levels</code>, which sets the contour levels to plot, and <code>cbar</code>, which tells the plotting routine not to plot a colorbar as it isn&#39;t useful in these contexts. Finally, <code>savefig</code> saves the plot to a file called <code>sod_xt.svg</code>.</p><div class="admonition is-success" id="Tip-e015f4644a8d74f1"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-e015f4644a8d74f1" title="Permalink"></a></header><div class="admonition-body"><p>The plot colors were set to black as this makes a uniform looking plot. However, you might try plotting the two with different colors (say, <code>c=:red</code> in one plot) as this will show how the positive and negative Riemann invariants correspond to left- and right-moving waves.</p></div></div><div class="admonition is-info" id="Note-717520381d52b89e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-717520381d52b89e" title="Permalink"></a></header><div class="admonition-body"><p>The <code>levels</code> argument, particularly the step size of <code>0.2</code>, was tuned to produce a good looking plot for this case. You will probably need to adjust this for other configurations.</p></div></div><p>With everything set up we can run our simulation and take a look at our plot. For illustration purposes, the final time in the simulation will be a later time in order to better show the movement of waves in the final plot.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; final_state = run_simulation( init_state, 1.0 )</code></pre><p><img src="../sod_xt.svg" alt/></p><p>and there we go! You can see the leftwards moving expansion wave and the rightwards moving shock and contact surface. Reflections off of the end walls are also visible, as are interactions between different waves. </p><div class="admonition is-success" id="Tip-739e025e3819b95"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-739e025e3819b95" title="Permalink"></a></header><div class="admonition-body"><p>You might notice that things like the material interface look a little wider than might be expected. Try playing around with the <code>artificial_viscosity_coefficient</code> and <code>artificial_conductivity_coefficient</code> values to see what effect these parameters have.</p></div></div><h2 id="Modifying-Problem-State"><a class="docs-heading-anchor" href="#Modifying-Problem-State">Modifying Problem State</a><a id="Modifying-Problem-State-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-Problem-State" title="Permalink"></a></h2><p>There may be cases where it is desirable to stop and modify the problem state part way through a simulation. For example, to add another shock wave. This can be done using the <a href="../FunctionReference/#Euler1D.UpdateSimulationState!"><code>UpdateSimulationState!()</code></a> function. This function takes four arguments that are <code>Function</code>s describing the new problem density, velocity, pressure, and ratio of specific heats. However, in this case the functions have a slightly different signature:</p><pre><code class="language-julia hljs">function my_new_state( x, oldValue )
    ...
end</code></pre><p>Notice that there is now an <code>oldValue</code> argument. This will hold the current value of the variable at the position <code>x</code>. If you don&#39;t want to modify anything, you can just return <code>oldValue</code> from this function.</p><p>As a trivial example, let&#39;s say we want to modify the example from the <a href="#Line-Plot">Line Plot</a> section to add a sinusoidal profile to the existing density, set the velocity to zero, and leave everything else untouched. Our functions might look like</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_density( x, oldValue )
           return 0.05 * sin( 20 * pi * x ) + 0.05 + oldValue # Need to add a value to make sure density doesn&#39;t go to zero
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_velocity( x, oldValue )
           return 0.0
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_pressure( x, oldValue )
           return oldValue
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_gamma( x, oldValue )
           return oldValue
       end;</code></pre><p>With these functions we can now update the problem state:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; UpdateSimulationState!( end_state, update_gamma, update_density, update_velocity, update_pressure )</code></pre><p>and if we plot density again, we&#39;ll see the density field has been updated:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot( end_state.zone_center, end_state.density );</code></pre><p><img src="../sod_density_updated.svg" alt/></p><p>and the velocity field is now zero everywhere:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot( end_state.zone_edge, end_state.velocity );</code></pre><p><img src="../sod_velocity_updated.svg" alt/></p><div class="admonition is-category-caution" id="Caution-6e22e87a8d7e3408"><header class="admonition-header">Caution<a class="admonition-anchor" href="#Caution-6e22e87a8d7e3408" title="Permalink"></a></header><div class="admonition-body"><p>The functions to update the simulation state were chosen to be illustrative, and it&#39;s likely the simulation would be unstable following this change. Care should be taken to ensure the updated state makes sense.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Euler1D</a><a class="docs-footer-nextpage" href="../Methodology/">Methodology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 18:07">Friday 1 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
