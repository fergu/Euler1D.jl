<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · Euler1D</title><meta name="title" content="Function Reference · Euler1D"/><meta property="og:title" content="Function Reference · Euler1D"/><meta property="twitter:title" content="Function Reference · Euler1D"/><meta name="description" content="Documentation for Euler1D."/><meta property="og:description" content="Documentation for Euler1D."/><meta property="twitter:description" content="Documentation for Euler1D."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Euler1D</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Euler1D</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../Methodology/">Methodology</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#Problem-Configuration"><span>Problem Configuration</span></a></li><li><a class="tocitem" href="#Callbacks"><span>Callbacks</span></a></li><li><a class="tocitem" href="#Timestepping"><span>Timestepping</span></a></li><li><a class="tocitem" href="#Equation-of-State"><span>Equation of State</span></a></li><li><a class="tocitem" href="#Artificial-Dissipation"><span>Artificial Dissipation</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Governing-Equations"><span>Governing Equations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl/blob/main/docs/src/FunctionReference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-Reference"><a class="docs-heading-anchor" href="#Function-Reference">Function Reference</a><a id="Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Reference" title="Permalink"></a></h1><h2 id="Problem-Configuration"><a class="docs-heading-anchor" href="#Problem-Configuration">Problem Configuration</a><a id="Problem-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Configuration" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Euler1D.DefaultSimulationParameters"><a class="docstring-binding" href="#Euler1D.DefaultSimulationParameters"><code>Euler1D.DefaultSimulationParameters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DefaultSimulationParameters()</code></pre><p>Return a set of default parameters for a simulation.</p><p><strong>Returns</strong></p><p>A <code>Dict{String, Any}</code> with default parameters for a simulation. </p><p><strong>Notes</strong></p><ul><li>Keys with a value of <code>nothing</code> must be set before using this dictionary to initialize a simulation. This is done instead of providing a default function to avoid the possibility of accidentally initializing a simulation with unintended initial conditions.</li></ul><p><strong>Parameters</strong></p><ul><li><code>start_time</code>: The initial time of the simulation. (Unit: s; Default: 0.0)</li><li><code>end_time</code>: The final time of the simulation. (Unit: s; Default: 1.0)</li><li><code>start_position</code>: The position of the left side of the domain. (Unit: m; Default: 0.0)</li><li><code>end_position</code>: The position of the right side of the domain. (Unit: m; Default: 1.0)</li><li><code>number_of_zones</code>: The number of zones to divide the domain into. (Unit: ⋅; Default: 1000)</li><li><code>CFL</code>: The CFL number to use. (Unit: ⋅; Default: 0.2)</li><li><code>artificial_viscosity_coefficient</code>: The coefficient to use for artificial viscosity. (Unit: ⋅; Default: 1e0)</li><li><code>artificial_conductivity_coefficient</code>: The coefficient to use for artificial conductivity. (Unit: ⋅; Default: 1e-2)</li><li><code>min_timestep</code>: The minimum allowable timestep size. Simulation will halt if timestep falls below this value. (Unit: s; Default: 1e-7)</li><li><code>max_cycles</code>: The maximum number of cycles to perform. Simulation will halt if more than this many timesteps are taken. (Unit: ⋅; Default: 1e6)</li><li><code>init_density_function</code>: A <code>Function</code> that returns the initial density as a function of position <code>x</code>. (Unit: kg/m³; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_velocity_function</code>: A <code>Function</code> that returns the initial velocity as a function of position <code>x</code>. (Unit: m/s; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_pressure_function</code>: A <code>Function</code> that returns the initial pressure as a function of position <code>x</code>. (Unit: N/m²; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_gamma_function</code>: A <code>Function</code> that returns the ratio of specific heats as a function of position <code>x</code>. (Unit: ⋅; Default: <code>nothing</code>, must be user-supplied)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Configuration.jl#L150-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.InitializeSimulation"><a class="docstring-binding" href="#Euler1D.InitializeSimulation"><code>Euler1D.InitializeSimulation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">InitializeSimulation( parameters::Dict{String, Any} )</code></pre><p>Initialize a simulation with the parameters provided by <code>parameters</code>. A default set of <code>parameters</code> can be returned from the <a href="#Euler1D.DefaultSimulationParameters"><code>DefaultSimulationParameters()</code></a> function.</p><p><strong>Returns</strong></p><p>A struct of type <code>Simulation{T}</code> that describes the current simulation state. The type <code>T</code> is determined by the type of the members of <code>parameters</code>.</p><p><strong>Notes</strong></p><ul><li>This function performs some basic sanity checking on input parameters such as ensuring that <code>end_time &gt; start_time</code> or <code>end_position &gt; start_position</code>, and will raise an error if any of these checks fail.</li><li>A warning will be raised if any keys in the dictionary are unused, but this will not halt execution.</li><li>This function will not warn about any potential issues with problem configuration or potential stability issues.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Configuration.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.UpdateSimulationState!"><a class="docstring-binding" href="#Euler1D.UpdateSimulationState!"><code>Euler1D.UpdateSimulationState!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">UpdateSimulationState!( state::Simulation{T}, gamma::Function, density::Function, velocity::Function, pressure::Function ) where { T &lt;: AbstractFloat }</code></pre><p>Update the simulation state using the supplied functions to define a new state. See Notes for information about the expected signature of the functions.</p><p><strong>Returns</strong></p><p><code>nothing</code>. Updates the <code>state</code> input in-place.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <code>Simulation{T}</code> representing the simulation state to be updated</li><li><code>gamma</code>: A <code>Function</code> that returns the new values of the ratio of specific heats, gamma</li><li><code>density</code>: A <code>Function</code> that returns the new values of the density</li><li><code>velocity</code>: A <code>Function</code> that returns the new values of velocity</li><li><code>pressure</code>: A <code>Function</code> that returns the new values of pressure</li></ul><p><strong>Notes</strong></p><p>Unlike the functions used in initial problem setup, the functions supplied to <code>UpdateSimulationState</code> have a slightly different expected signature of     ExampleFunction( x::T, oldValue::T ) where { T &lt;: AbstractFloat } where <code>oldValue</code> will be the current value of the state variable at current position <code>x</code> (e.g., the previous value of pressure).</p><p><strong>Side Effects</strong></p><ul><li>Updates the values stored in the vectors for <code>state.gamma</code>, <code>state.mass</code>, <code>state.velocity</code>, <code>state.intenergy</code>, and fields derived from the equation of state in-place.</li></ul><div class="admonition is-warning" id="Warning-2411058c65c90ee7"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2411058c65c90ee7" title="Permalink"></a></header><div class="admonition-body"><p>If the <code>density</code> function alters the <code>state.density</code> field (that is, it does not just return <code>oldValue</code>), mass will be added or removed from a given zone to achieve a specified value of <code>density</code> without changing zone size. As a consequence, mass will not be conserved in the system in this case.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Configuration.jl#L114-L139">source</a></section></details></article><h2 id="Callbacks"><a class="docs-heading-anchor" href="#Callbacks">Callbacks</a><a id="Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Euler1D.ConfigureSimulationCallbacks"><a class="docstring-binding" href="#Euler1D.ConfigureSimulationCallbacks"><code>Euler1D.ConfigureSimulationCallbacks</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ConfigureSimulationCallbacks( simulation::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Configure a <a href="#Euler1D.SimulationCallback"><code>SimulationCallback</code></a> structure for setting up callbacks as part of a simulation run.</p><p><strong>Returns</strong></p><ul><li>A <a href="#Euler1D.SimulationCallback"><code>SimulationCallback</code></a> structure</li></ul><p><strong>Parameters</strong></p><ul><li><code>simulation</code>: A <code>Simulation{T}</code> describing the simulation that the callbacks are intended for.</li></ul><p><strong>Notes</strong></p><ul><li>Currently, the <code>simulation</code> parameter has no effect in this function and the resulting <a href="#Euler1D.SimulationCallback"><code>SimulationCallback</code></a> structure can be used by any simulation, not just the one passed as an argument. However, this may change in future version.</li><li>Callback entries can be added using <a href="#Euler1D.RegisterCycleCallback!"><code>RegisterCycleCallback!()</code></a>, <a href="#Euler1D.RegisterTimeCallback!"><code>RegisterTimeCallback!()</code></a>, or <a href="#Euler1D.RegisterTimeDeltaCallback!"><code>RegisterTimeDeltaCallback!()</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Callbacks.jl#L40-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.RegisterCycleCallback!"><a class="docstring-binding" href="#Euler1D.RegisterCycleCallback!"><code>Euler1D.RegisterCycleCallback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">RegisterCycleCallback!( callbacks::SimulationCallback, func::Function, N::UInt; initial_cycle::UInt=0 )</code></pre><p>Register a function <code>func</code> to be executed every <code>N</code> cycles of the simulation starting at cycle <code>initial_cycle</code>. Callbacks are stored in the <code>callbacks</code> input parameter and passed as an argument to the timestepping routines</p><p><strong>Returns</strong></p><p><code>nothing</code>, mutates the <code>callbacks</code> parameter</p><p><strong>Parameters</strong></p><ul><li><code>callbacks</code>: A <code>SimulationCallback</code> that describes the callbacks to be executed</li><li><code>func</code>: A <code>Function</code> that should be called by this callback. See Notes for information on expected function signature</li><li><code>N</code>: A <code>UInt</code> indicating how many cycles should occur between callbacks. Must be N ≥ 1</li><li><code>initial_cycle</code>: A <code>UInt</code> indicating the cycle number to start calling this callback at (Default: 0)</li></ul><p><strong>Notes</strong></p><ul><li><code>func</code> is expected to accept arguments of the form <code>CallbackFunction( arg::Simulation{T} ) where { T &lt;: AbstractFloat }</code>. <code>arg</code> will be the simulation state at the end of the cycle that the callback is executed on.</li><li>This type of callback is useful for cases where a callback should be called at a fixed number of cycles between each callback.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Callbacks.jl#L64-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.RegisterTimeCallback!"><a class="docstring-binding" href="#Euler1D.RegisterTimeCallback!"><code>Euler1D.RegisterTimeCallback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">RegisterTimeCallback!( callbacks::SimulationCallback, func::Function, times::Vector{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Register a function <code>func</code> to be executed at the list of times specified in <code>times</code>. Callbacks are stored in the <code>callbacks</code> input parameter and passed as an argument to the timestepping routines</p><p><strong>Returns</strong></p><p><code>nothing</code>, mutates the <code>callbacks</code> parameter</p><p><strong>Parameters</strong></p><ul><li><code>callbacks</code>: A <code>SimulationCallback</code> that describes the callbacks to be executed</li><li><code>func</code>: A <code>Function</code> that should be called by this callback. See Notes for information on expected function signature</li><li><code>times</code>: A <code>Vector{T}</code> indicating the times at which to execute the callback</li></ul><p><strong>Notes</strong></p><ul><li><code>func</code> is expected to accept arguments of the form <code>CallbackFunction( arg::Simulation{T} ) where { T &lt;: AbstractFloat }</code>. <code>arg</code> will be the simulation state at the end of the cycle that the callback is executed on.</li><li>Callbacks are executed at the end of the first cycle where the simulation time is greater than the next element in <code>times</code>. As a result, it is not guaranteed that the callback will be called at exactly the time specified in the <code>times</code> vector.</li><li><code>times</code> is sorted into ascending order before being stored. </li><li>This type of callback is useful if the callback should be called at an irregular series of times. See <a href="#Euler1D.CycleCallback"><code>CycleCallback</code></a> if the callback should be called at a regular number of cycles, or <a href="#Euler1D.TimeDeltaCallback"><code>TimeDeltaCallback</code></a> if the callback should be called at a fixed temporal cadence.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Callbacks.jl#L99-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.RegisterTimeDeltaCallback!"><a class="docstring-binding" href="#Euler1D.RegisterTimeDeltaCallback!"><code>Euler1D.RegisterTimeDeltaCallback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">RegisterTimeDeltaCallback!( callbacks::SimulationCallback, func::Function, delta::T, initial_time::T=T(0.0) ) where { T &lt;: AbstractFloat }</code></pre><p>Register a function <code>func</code> to be executed every <code>delta</code> seconds starting at <code>initial_time</code>. Callbacks are stored in the <code>callbacks</code> input parameter and passed as an argument to the timestepping routines</p><p><strong>Returns</strong></p><p><code>nothing</code>, mutates the <code>callbacks</code> parameter</p><p><strong>Parameters</strong></p><ul><li><code>callbacks</code>: A <code>SimulationCallback</code> that describes the callbacks to be executed</li><li><code>func</code>: A <code>Function</code> that should be called by this callback. See Notes for information on expected function signature</li><li><code>delta</code>: A scalar <code>T</code> indicating how often to execute the callback</li><li><code>inital_time</code>: A scalar <code>T</code> indicating the time of the first callback to execute. (Default: 0.0)</li></ul><p><strong>Notes</strong></p><ul><li><code>func</code> is expected to accept arguments of the form <code>CallbackFunction( arg::Simulation{T} ) where { T &lt;: AbstractFloat }</code>. <code>arg</code> will be the simulation state at the end of the cycle that the callback is executed on.</li><li>Callbacks are executed at the end of the first cycle where the simulation time is greater than the last time the callback was executed plus <code>delta</code>. As a result, it is not guaranteed that the callback will be called at exactly <code>delta</code> seconds since the last call.</li><li>The time of the next callback is computed relative to the expected time of the current callback, <em>not</em> when the callback was actually called. In other words, if a callback that should be called at <code>t₀</code> was actually called at <code>t₀+ϵ</code> due to the timestep size, the next callback will be scheduled for <code>t₀+δ</code>, <em>not</em> <code>t₀+ϵ+δ</code>.</li><li>This type of callback is useful for cases where a callback should be called at a fixed temporal spacing between each callback.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Callbacks.jl#L136-L155">source</a></section></details></article><h2 id="Timestepping"><a class="docs-heading-anchor" href="#Timestepping">Timestepping</a><a id="Timestepping-1"></a><a class="docs-heading-anchor-permalink" href="#Timestepping" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Euler1D.AdvanceToTime"><a class="docstring-binding" href="#Euler1D.AdvanceToTime"><code>Euler1D.AdvanceToTime</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdvanceToTime( state::Simulation{T}, stoptime::T; timestep::Union{T,Nothing}=nothing, exact::Bool=false, callbacks::Union{SimulationCallback,Nothing}=nothing ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation with initial state <code>state</code> to a time specified by <code>stoptime</code> with a fixed timestep. </p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the final cycle.</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>stoptime</code>: The time to advance to. (Unit: s)</li><li><code>timestep</code>: The timestep size, or <code>nothing</code> to use adaptive timestepping. (Unit: s, Default: <code>nothing</code>)</li><li><code>exact</code>: If true, try to stop as close as possible to <code>stoptime</code> by adjusting the final timestep size (Default: <code>false</code>)</li><li><code>callbacks</code>: An optional <a href="#Euler1D.SimulationCallback"><code>SimulationCallback()</code></a> structure containing information about callbacks to be performed during the simulation.</li></ul><p><strong>Notes</strong></p><ul><li>The current simulation time is determined by the <code>Simulation</code> field <code>state.time</code>. If <code>state.time &gt; stoptime</code>, no steps will be taken.</li><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function simply calls <code>AdvanceOneCycle!</code> repeatedly until the simulation time reaches <code>stoptime</code>. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> or <a href="#Euler1D.AdvanceNCycles"><code>AdvanceNCycles()</code></a> is that various backing arrays are pre-allocated to improve speed.</li><li>If <code>exact=true</code>, the timestep of the final cycle is adjusted so that the time of the final state is as close as possible to <code>stoptime</code>.</li><li>If using adaptive timestepping, the timestep size is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Timestepping.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.AdvanceOneCycle"><a class="docstring-binding" href="#Euler1D.AdvanceOneCycle"><code>Euler1D.AdvanceOneCycle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdvanceOneCycle( state::Simulation{T}; timestep::Union{T,Nothing}=nothing, callbacks::Union{SimulationCallback,Nothing}=nothing ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle.</p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the cycle</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the cycle.</li><li><code>timestep</code>: The size of the time step, or <code>nothing</code> to use adaptive timestepping. (Unit: s, Default: <code>nothing</code>)</li><li><code>callbacks</code>: An optional <a href="#Euler1D.SimulationCallback"><code>SimulationCallback()</code></a> structure containing information about callbacks to be performed during the simulation.</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates a <code>deepcopy()</code> of the input state. The copy is modified and returned from this function.</li><li>If using adaptive timestepping, the timestep size is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Timestepping.jl#L77-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.AdvanceOneCycle!"><a class="docstring-binding" href="#Euler1D.AdvanceOneCycle!"><code>Euler1D.AdvanceOneCycle!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdvanceOneCycle!( output::Simulation{T}, input::Simulation{T}; timestep::Union{T,Nothing}=nothing, callbacks::Union{SimulationCallback,Nothing}=nothing ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle.</p><p><strong>Returns</strong></p><p><code>nothing</code>. Modifies <code>output</code> in-place.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: A <code>Simulation{T}</code> that will represent the output state. This will be modified by the function to represent the simulation state after advancing one cycle.</li><li><code>input</code>: A <code>Simulation{T}</code> that represents the simulation state at the start of the cycle.</li><li><code>timestep</code>: The size of the time step, or <code>nothing</code> to use adaptive timestepping. (Unit: s, Default: <code>nothing</code>)</li><li><code>callbacks</code>: An optional <a href="#Euler1D.SimulationCallback"><code>SimulationCallback()</code></a> structure containing information about callbacks to be performed during the simulation.</li></ul><p><strong>Side Effects</strong></p><ul><li>All fields of <code>output</code> are modified in-place.</li><li>If using adaptive timestepping, the timestep size is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Timestepping.jl#L47-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.AdvanceNCycles"><a class="docstring-binding" href="#Euler1D.AdvanceNCycles"><code>Euler1D.AdvanceNCycles</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdvanceNCycles( state::Simulation{T}, ncycles::UInt; timestep::Union{T,Nothing}=nothing, callbacks::Union{SimulationCallback,Nothing}=nothing ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by <code>ncycles</code> cycles.</p><p><strong>Returns</strong></p><ul><li>A <code>Simulation{T}</code> representing the state at the end of the final cycle</li></ul><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>ncycles</code>: The number of cycles to advance.</li><li><code>timestep</code>: The size of the time step, or <code>nothing</code> to use adaptive timestepping. (Unit: s, Default: nothing)</li><li><code>callbacks</code>: An optional <a href="#Euler1D.SimulationCallback"><code>SimulationCallback()</code></a> structure containing information about callbacks to be performed during the simulation.</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function calls <a href="#Euler1D.AdvanceOneCycle!"><code>AdvanceOneCycle!()</code></a> a total of <code>ncycles</code> times to advance the simulation. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> if the number of cycles to advance is known is that various backing arrays are pre-allocated to improve speed.</li><li>If using adaptive timestepping, the timestep size is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Timestepping.jl#L100-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.CalculateTimestepSize"><a class="docstring-binding" href="#Euler1D.CalculateTimestepSize"><code>Euler1D.CalculateTimestepSize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">CalculateTimestepSize( state::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an automatic timestep size for the next simulation cycle based on the current simulation state. See the Notes section for details on how the timestep is determined.</p><p><strong>Returns</strong></p><ul><li>A scalar of type <code>T</code> representing the timestep size for the next cycle based on the current simulation state.</li></ul><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <code>Simulation{T}</code> representing the problem state.</li></ul><p><strong>Notes</strong></p><ul><li>For each zone, the local speed of sound is computed according to <code>c = √( γ P / ρ )</code>, where γ, P, and ρ are the ratio of specific heats, the pressure, and the density of the gas in that zone.</li><li>The time for an acoustic wave to traverse a zone with length <code>Δx</code> is computed as <code>t = Δx / c</code>.</li><li>The minimum traversal time for all zones is multiplied by the user-specified CFL number to obtain the timestep size.</li><li>Sanity checking for negative zone sizes and small timesteps is performed to detect problem instability.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Timestepping.jl#L138-L154">source</a></section></details></article><h2 id="Equation-of-State"><a class="docs-heading-anchor" href="#Equation-of-State">Equation of State</a><a id="Equation-of-State-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-of-State" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Euler1D.EOS_Density"><a class="docstring-binding" href="#Euler1D.EOS_Density"><code>Euler1D.EOS_Density</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">EOS_Density( mass::T, Δx::T ) where { T &lt;: AbstractFloat } = mass / Δx</code></pre><p>Compute the density of the fluid in a zone.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the density of a zone.</p><p><strong>Arguments</strong></p><ul><li><code>mass</code>: The total mass contained within the zone. (Unit: kg)</li><li><code>Δx</code>: The size of the zone. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>Density is calculated as:</p><pre><code class="nohighlight hljs">ρ = mass / Δx</code></pre><p>As this is the physical definition of density, this calculation does not assume any particular equation of state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/EquationOfState.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.EOS_Pressure"><a class="docstring-binding" href="#Euler1D.EOS_Pressure"><code>Euler1D.EOS_Pressure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">EOS_Pressure( γ::T, ρ::T, e::T ) where { T &lt;: AbstractFloat }
EOS_Pressure( γ::T, mass::T, Δx::T, e::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the pressure of a zone using an ideal gas equation of state.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the pressure within the zone.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: The ratio of specific heats of the fluid in the zone. (Unit: ⋅)</li><li><code>ρ</code>: The density of the zone. (Unit: kg/m³)</li><li><code>mass</code>: The total mass contained within the zone. (Unit: kg)</li><li><code>Δx</code>: The size of the zone. (Unit: m)</li><li><code>e</code>: The internal energy per unit mass of the zone. (Unit: m²/s²)</li></ul><p><strong>Notes</strong></p><p>The pressure is calculated as:</p><pre><code class="nohighlight hljs">P = ( γ - 1 ) ⋅ ρ ⋅ e</code></pre><p>The four-parameter version of this function computes density using <a href="#Euler1D.EOS_Density"><code>EOS_Density()</code></a>. See the documentation for that function for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/EquationOfState.jl#L45-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.EOS_SpeedOfSound"><a class="docstring-binding" href="#Euler1D.EOS_SpeedOfSound"><code>Euler1D.EOS_SpeedOfSound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">EOS_SpeedOfSound( γ::T, P::T, ρ::T ) where { T &lt;: AbstractFloat }
EOS_SpeedOfSound( γ::T, e::T, mass::T, Δx::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the speed of sound in a zone using an ideal gas equation of state.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the speed of sound in the zone.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: The ratio of specific heats in the zone. (Unit: ⋅)</li><li><code>e</code>: The internal energy per unit mass in the zone. (Unit: m²/s²)</li><li><code>P</code>: The pressure in the zone. (Unit: kg/(m⋅s²))</li><li><code>ρ</code>: The density of the fluid in the zone. (Unit: kg/m³)</li><li><code>mass</code>: The mass contained in the zone. (Unit: kg)</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>The speed of sound is calculated as:</p><pre><code class="nohighlight hljs">c = √( γ * P / ρ )</code></pre><p>The four-parameter version of this function computes density using <a href="#Euler1D.EOS_Density"><code>EOS_Density()</code></a> and pressure using <a href="#Euler1D.EOS_Pressure"><code>EOS_Pressure()</code></a>. See the documentation of those functions for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/EquationOfState.jl#L94-L117">source</a></section></details></article><h2 id="Artificial-Dissipation"><a class="docs-heading-anchor" href="#Artificial-Dissipation">Artificial Dissipation</a><a id="Artificial-Dissipation-1"></a><a class="docs-heading-anchor-permalink" href="#Artificial-Dissipation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Euler1D.artificial_viscosity"><a class="docstring-binding" href="#Euler1D.artificial_viscosity"><code>Euler1D.artificial_viscosity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">artificial_viscosity( Cᵥ::T, c::T, ρ::T, Δx::T, u₋::T, u₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an artificial viscosity within a zone. </p><p><strong>Returns</strong></p><p>A value of type <code>T</code> representing the value of the artificial viscosity.</p><p><strong>Arguments</strong></p><ul><li><code>Cᵥ</code>: An O(1) coefficient to control the strength of the artificial viscosity. (Unit: ⋅)</li><li><code>c</code>: The speed of sound in the zone. (Unit: m/s)</li><li><code>ρ</code>: The density of the zone. (Unit: kg/m³)</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li><li><code>u</code>: The velocity of the zone boundaries, with superscripts - and + referring to the left and right boundaries of the zone, respectively. (Unit: m/s)</li></ul><p><strong>Notes</strong></p><ul><li>This artificial viscosity is based on the method described by Wilkins (1980), which in turn relies upon the methods of Von Neumann and Richtmyer (1950) and Landschoff (1955). The values computed by this function should be added to the pressure field during governing equation updates.</li><li>This function returns zero if <code>∂u/∂x &gt; 0</code>, which will be the case for regions where the flow is expanding. This is done to restrict artificial viscosity only to regions of compression.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/ArtificialDissipation.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.artificial_conductivity"><a class="docstring-binding" href="#Euler1D.artificial_conductivity"><code>Euler1D.artificial_conductivity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">artificial_conductivity( Cₖ::T, u::T, c₋::T, e₋::T, Δx₋::T, c₊::T, e₊::T, Δx₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an artificial flux of internal energy across a zone interface.</p><p><strong>Returns</strong></p><p>A value of type <code>T</code> representing the artifical flux of internal energy across a zone boundary.</p><p><strong>Arguments</strong></p><ul><li><code>Cₖ</code>: An O(1) coefficient to control the strength of the artificial conductivity. (Unit: ⋅)</li><li><code>u</code>: The velocity of the zone interface. (Unit: m/s)</li><li><code>c</code>: The speed of sound, where superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m/s)</li><li><code>e</code>: The internal energy per unit mass. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m²/s²)</li><li><code>Δx</code>: Length of the zone. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>The artificial conductivity is modeled as a Fickian diffusivity. That is, the flux of energy across a zone boundary, fₑ, is described by</p><pre><code class="nohighlight hljs">fₑ = -κ ∂e/∂x</code></pre><p>where e is the internal energy per unit mass and κ is the (artificial) conductivity coefficient. The gradient of internal energy is treated with a simple forward finite difference. The artificial conductivity coefficient is modeled as</p><pre><code class="nohighlight hljs">κ = Cₖ * cₘ * Δx</code></pre><p>where</p><ul><li><code>Cₖ</code> an O(1) coefficient.</li><li><code>cₘ</code>  is a characteristic velocity taken to be max(c̄±u, c̄), where c̄=0.5*(c₋+c₊) is the average speed of sound of the two adjacent zones and u is the velocity of the zone interface. </li><li><code>Δx</code> is the distance between the zone centers</li></ul><p>By convention, this leads to a positive flux if energy is diffusing in the positive x direction, and negative if it is diffusing in the negative x direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/ArtificialDissipation.jl#L53-L84">source</a></section></details></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Euler1D.Simulation"><a class="docstring-binding" href="#Euler1D.Simulation"><code>Euler1D.Simulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Simulation{T}</code></pre><p>A structure containing all the internal variables and arrays used in the simulation.</p><p><strong>Parameters</strong></p><ul><li><code>nzones::Int</code>: The number of zones in the simulation. (Unit: ⋅)</li><li><code>nedges::Int</code>: The number of zone edges in the simulation, equal to <code>nzones + 1</code>. (Unit: ⋅)</li><li><code>CFL::Float64</code>: The CFL number to be used when calculating timesteps. (Unit: ⋅)</li><li><code>start_time::Float64</code>: The initial time of the simulation. (Unit: s)</li><li><code>viscosity_coefficient::Float64</code>: The coefficient used to scale artificial viscosity. (Unit: ⋅)</li><li><code>conductivity_coefficient::Float64</code>: The coefficient used to scale artificial conductivity. (Unit: ⋅)</li><li><code>time::Base.RefValue{T}</code>: The current time of the simulation. (Unit: s)</li><li><code>dt::Base.RefValue{T}</code>: The size of the timestep taken in the last cycle. (Unit: s)</li><li><code>cycles::Base.RefValue{UInt}</code>: The number of cycles performed so far. (Unit: ⋅)</li><li><code>min_dt::Float64</code>: The minimum allowable timestep size. Simulation will halt if <code>Δt</code> falls below this value. (Unit: s)</li><li><code>max_cycles::UInt</code>: The maximum number of cycles to perform. Simulation will halt if <code>cycles</code> exceeds this value. (Unit: ⋅)</li><li><code>zone_edge::Vector{T}</code>: A vector of locations of zone edges. Increases monotonically. (Unit: m)</li><li><code>zone_center::Vector{T}</code>: A vector of locations of zone centers, defined as the midpoint between two zone edges. Increases monotonically. (Unit: m)</li><li><code>zone_length::Vector{T}</code>: A vector of the length of each zone. (Unit: m)</li><li><code>gamma::Vector{T}</code>: A vector of the ratio of specific heats inside each zone. (Unit: ⋅)</li><li><code>mass::Vector{T}</code>: A vector of the mass contained within each zone. Assumed constant. (Unit: kg)</li><li><code>density::Vector{T}</code>: A vector of the density of the fluid within each zone. Computed using the equation of state as mass/Δx. (Unit: kg/m³)</li><li><code>velocity::Vector{T}</code>: A vector of velocities of zone edges. (Unit: m/s)</li><li><code>pressure::Vector{T}</code>: A vector of pressures inside each zone. Computed from the equation of state. (Unit: kg/(m⋅s²))</li><li><code>intenergy::Vector{T}</code>: A vector of the internal energy per unit mass of each zone. (Unit: m²/s²)</li><li><code>speedofsound::Vector{T}</code>: A vector of the speed of sound within each zone. Computed from the equation of state. (Unit: m/s)</li><li><code>viscosity::Vector{T}</code>: A vector of the artificial viscosity within each zone, added to the pressure field. See ArtificialDissipation.jl for more information. (Unit: kg/(m⋅s²))</li><li><code>energy_flux::Vector{T}</code>: A vector of fluxes of internal energy per unit mass across each zone boundary. Added to the energy equation as a diffusion term. See ArtificialDissipation.jl for more information. (Unit: m³/s³)</li><li><code>momentum_rhs::Vector{T}</code>: A vector of the right hand side of the momentum equation at each zone edge. (Unit: m/s²)</li><li><code>energy_rhs::Vector{T}</code>: A vector of the right hand side of the energy equation within each zone. (Unit: m²/s³)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Types.jl#L85-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.SimulationCallback"><a class="docstring-binding" href="#Euler1D.SimulationCallback"><code>Euler1D.SimulationCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SimulationCallback</code></pre><p>A structure containing callbacks to be called by a simulation.</p><p><strong>Parameters</strong></p><ul><li><code>callback_cycle</code>: A <code>Vector</code> of <a href="#Euler1D.CycleCallback"><code>CycleCallback</code></a>&#39;s that are called based on the number of cycles (timesteps) that have been performed</li><li><code>callback_time</code>: A <code>Vector</code> of <a href="#Euler1D.TimeCallback"><code>TimeCallback</code></a>&#39;s that are called at a fixed set of times</li><li><code>callback_dt</code>: A <code>Vector</code> of <a href="#Euler1D.TimeDeltaCallback"><code>TimeDeltaCallback</code></a>&#39;s that are called at a fixed temporal frequency</li></ul><p><strong>Notes</strong></p><ul><li>This structure is typically initialized using <a href="#Euler1D.ConfigureSimulationCallbacks"><code>ConfigureSimulationCallbacks()</code></a>. See the documentation of that function for further detail.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Types.jl#L65-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.CycleCallback"><a class="docstring-binding" href="#Euler1D.CycleCallback"><code>Euler1D.CycleCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CycleCallback</code></pre><p>A structure containing information about a callback intended to be executed every <code>every</code> cycles</p><p><strong>Parameters</strong></p><ul><li><code>func</code>: The <code>Function</code> to be executed</li><li><code>every</code>: How often (in cycles) to execute this callback</li><li><code>last_called</code>: The last cycle that this callback was called</li></ul><p><strong>Notes</strong></p><ul><li>This type of callback is useful for cases where a callback should be called at a fixed number of cycles between each callback.</li><li>While this structure can be initialized directly and added to the <code>callback_cycle</code> entry of a <a href="#Euler1D.SimulationCallback"><code>SimulationCallback</code></a> structure, it is recommended to call <a href="#Euler1D.RegisterCycleCallback!"><code>RegisterCycleCallback!()</code></a> instead.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Types.jl#L4-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.TimeCallback"><a class="docstring-binding" href="#Euler1D.TimeCallback"><code>Euler1D.TimeCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TimeCallback</code></pre><p>A structure containing information about a callback intended to be executed at a fixed list of times given by <code>times</code>.</p><p><strong>Parameters</strong></p><ul><li><code>func</code>: The <code>Function</code> to be executed</li><li><code>times</code>: The list of times at which to execute this callback</li><li><code>next_index</code>: An index into the <code>times</code> vector indicating the next time the callback should be executed.</li></ul><p><strong>Notes</strong></p><ul><li>This type of callback is useful if the callback should be called at an irregular series of times. See <a href="#Euler1D.CycleCallback"><code>CycleCallback</code></a> if the callback should be called at a regular number of cycles, or <a href="#Euler1D.TimeDeltaCallback"><code>TimeDeltaCallback</code></a> if the callback should be called at a fixed temporal cadence.</li><li>While this structure can be initialized directly and added to the <code>callback_time</code> entry of a <a href="#Euler1D.SimulationCallback"><code>SimulationCallback</code></a> structure, it is recommended to call <a href="#Euler1D.RegisterTimeCallback!"><code>RegisterTimeCallback!()</code></a> instead.</li><li>The entries in <code>times</code> are assumed to be sorted in ascending order. <a href="#Euler1D.RegisterTimeCallback!"><code>RegisterTimeCallback!()</code></a> will handle this automatically, but this will need to be handled manually if creating this structure directly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Types.jl#L24-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.TimeDeltaCallback"><a class="docstring-binding" href="#Euler1D.TimeDeltaCallback"><code>Euler1D.TimeDeltaCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TimeDeltaCallback</code></pre><p>A structure containing information about a callback intended to be executed every <code>every</code> seconds</p><p><strong>Parameters</strong></p><ul><li><code>func</code>: The <code>Function</code> to be executed</li><li><code>every</code>: How often (in seconds) to execute this callback</li><li><code>last_called</code>: The last time that this callback was called</li></ul><p><strong>Notes</strong></p><ul><li>This type of callback is useful for cases where a callback should be called at a fixed temporal spacing between each callback.</li><li>While this structure can be initialized directly and added to the <code>callback_dt</code> entry of a <a href="#Euler1D.SimulationCallback"><code>SimulationCallback</code></a> structure, it is recommended to call <a href="#Euler1D.RegisterTimeDeltaCallback!"><code>RegisterTimeDeltaCallback!()</code></a> instead.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/Types.jl#L45-L58">source</a></section></details></article><h2 id="Governing-Equations"><a class="docs-heading-anchor" href="#Governing-Equations">Governing Equations</a><a id="Governing-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Governing-Equations" title="Permalink"></a></h2><div class="admonition is-info" id="Note-12044dd84b829353"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-12044dd84b829353" title="Permalink"></a></header><div class="admonition-body"><p>These functions are not intended to be called directly as part of simulation setup. However, as their functionality is central to this package, they are documented here for reference.</p></div></div><article><details class="docstring" open="true"><summary id="Euler1D.Momentum"><a class="docstring-binding" href="#Euler1D.Momentum"><code>Euler1D.Momentum</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Momentum( m₋::T, P₋::T, m₊::T, P₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the momentum equation at a zone interface. See the Notes section for information on the equation being solved.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the rate of change of velocity of a zone interface over time.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The mass of the zone. (Unit: kg)</li><li><code>P</code>: The pressure of the zone (Unit: kg/(m⋅s²))</li></ul><p>For each of these parameters, a - subscript refers to the zone to the left of the zone interface and a + subscript refers to the zone to the right of the zone interface.</p><p><strong>Notes</strong></p><p>The governing equation solved in this function is:     ∂u/∂t = (1/ρ₀) * ∂P/∂x Through the numerical disretization, this reduces to     ∂u/∂t = 1/m̄ ( P₊ - P₋ ) If using artificial viscosity per the method of Von Neumann and Richtmyer (1950), the artificial viscosity term should be added to the pressure field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/EulerEquations.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Euler1D.Energy"><a class="docstring-binding" href="#Euler1D.Energy"><code>Euler1D.Energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Energy( ρ::T, P::T, Δx::T, u₋::T, u₊::T, q₋::T, q₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the energy equation in a zone. See the Notes section for the specific equations that are solved.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the rate of change of internal energy inside the zone.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The mass of the zone. (Unit: kg)</li><li><code>P</code>: The pressure of the zone. (Unit: kg/(m⋅s²))</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li><li><code>u</code>: The velocity of the zone edges on the (-): left and (+): right of the zone. (Unit: m/s)</li><li><code>q</code>: The (artificial) flux of internal energy across the (-): left and (+): right zone edges. (Unit: m³/s³) </li></ul><p><strong>Notes:</strong></p><p>The governing equation solved in this function is     ∂e/∂t = - ( P / ρ₀ ) * ∂u/∂x + ∑q Through discretization, this becomes     ∂eᵢ/∂t = - ( Pᵢ / mᵢ ) * ( u₊ - u₋ ) + ∑q </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/91a02d13c48e1a33646619e2304d16c0372775d2/src/EulerEquations.jl#L52-L72">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Methodology/">« Methodology</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 2 January 2026 01:59">Friday 2 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
