<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Euler1D</title><meta name="title" content="Examples · Euler1D"/><meta property="og:title" content="Examples · Euler1D"/><meta property="twitter:title" content="Examples · Euler1D"/><meta name="description" content="Documentation for Euler1D."/><meta property="og:description" content="Documentation for Euler1D."/><meta property="twitter:description" content="Documentation for Euler1D."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Euler1D</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Euler1D</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Sod-Shock-Tube"><span>Sod Shock Tube</span></a></li><li><a class="tocitem" href="#Callbacks"><span>Callbacks</span></a></li><li><a class="tocitem" href="#Plotting-Results"><span>Plotting Results</span></a></li><li><a class="tocitem" href="#Modifying-Problem-State"><span>Modifying Problem State</span></a></li></ul></li><li><a class="tocitem" href="../Methodology/">Methodology</a></li><li><a class="tocitem" href="../FunctionReference/">Function Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl/blob/main/docs/src/Examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Sod-Shock-Tube"><a class="docs-heading-anchor" href="#Sod-Shock-Tube">Sod Shock Tube</a><a id="Sod-Shock-Tube-1"></a><a class="docs-heading-anchor-permalink" href="#Sod-Shock-Tube" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Sod_shock_tube">Sod shock tube</a> is a case involving a rightwards travelling shock wave and a leftwards travelling expansion wave. Its initial condition is given by:</p><p class="math-container">\[\left(
\begin{aligned}
\rho_L \\
P_L \\
u_L
\end{aligned}
\right) =
\left(
\begin{aligned}
1.0 \\
1.0 \\
0.0
\end{aligned}
\right),~
\left(
\begin{aligned}
\rho_R \\
P_R \\
u_R
\end{aligned}
\right) =
\left(
\begin{aligned}
0.125 \\
0.1 \\
0.0
\end{aligned}
\right)\]</p><p>where <span>$\rho$</span>, <span>$P$</span>, and <span>$u$</span> are the density, pressure, and velocity, the domain is in the range <span>$x=[0,1]$</span>, and the subscripts <code>L</code> and <code>R</code> refer to states to the left and right of an interface initially located at <span>$x=0.5$</span>. While an exact solution for this configuration can be found, this example will focus on setting up an <code>Euler1D</code> simulation to simulate the Sod shock tube.</p><p>A simulation is initialized using a set of dictionary key:value pairs describing various aspects of the simulation, including the functions used to describe the initial profiles of density, velocity, pressure, and the ratio of specific heats. A default set of parameters can be obtained using the function [<code>DefaultSimulationParameters()</code>][@ref]:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Euler1D</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters = DefaultSimulationParameters()</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Any} with 13 entries:
  &quot;artificial_conductivity_coefficient&quot; =&gt; 0.01
  &quot;init_pressure_function&quot;              =&gt; nothing
  &quot;artificial_viscosity_coefficient&quot;    =&gt; 1.0
  &quot;init_gamma_function&quot;                 =&gt; nothing
  &quot;number_of_zones&quot;                     =&gt; 1000
  &quot;end_position&quot;                        =&gt; 1.0
  &quot;maximum_cycles&quot;                      =&gt; 1.0e6
  &quot;start_position&quot;                      =&gt; 0.0
  &quot;start_time&quot;                          =&gt; 0.0
  &quot;init_velocity_function&quot;              =&gt; nothing
  &quot;CFL&quot;                                 =&gt; 0.2
  &quot;minimum_timestep&quot;                    =&gt; 1.0e-7
  &quot;init_density_function&quot;               =&gt; nothing</code></pre><p>You may notice that there are several parameters with a value of <code>nothing</code>. These must be supplied before the simulation can be initialized since it is difficult to make reasonable default assumptions. Of particular note are the keys <code>init_density_function</code>, <code>init_velocity_function</code>, <code>init_pressure_function</code>, and <code>init_gamma_function</code>. These refer to functions that describe the inital profiles of density, velocity, pressure, and the ratio of specific heats, respectively. A set of functions to implement the Sod shock tube initial conditions looks like:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_density( x )
           if ( x &lt; 0.5 )
               return 1.0
           else
               return 0.125
           end
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_velocity( x )
           return 0.0
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_pressure( x )
           if ( x &lt; 0.5 )
               return 1.0
           else
               return 0.1
           end
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function init_gamma( x )
           return 1.4
       end;</code></pre><div class="admonition is-category-caution" id="Caution-99d9a288389a3aa6"><header class="admonition-header">Caution<a class="admonition-anchor" href="#Caution-99d9a288389a3aa6" title="Permalink"></a></header><div class="admonition-body"><p>The <code>x</code> argument in these functions is the location of where a given variable will be stored. Due to the fact that some variables are zone-centered while others are edge-centered, it should not be assumed that <code>x</code> will have the same value in all functions. Additionally, due to how Julia performs vectorized computations, these functions should not assume anything about the order in which they are executed. i.e., that the <code>n</code>-th function call will always have a certain value of <code>x</code>.</p></div></div><p>The <code>simulation_parameters</code> dictionary can now be modified to describe the desired initial condition. In this case, this would look like:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_density_function&quot;] = init_density;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_velocity_function&quot;] = init_velocity;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_pressure_function&quot;] = init_pressure;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_gamma_function&quot;] = init_gamma;</code></pre><p>The <code>simulation_parameters</code> dictionary has many other keys that can be modified. See <a href="../FunctionReference/#Euler1D.DefaultSimulationParameters"><code>DefaultSimulationParameters()</code></a> for a list of parameters that can be set.</p><p>Once all desired parameters have been set, the simulation can be initialized:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_state = InitializeSimulation( simulation_parameters )</code><code class="nohighlight hljs ansi" style="display:block;">Euler1D simulation
	Start time: 0.0
	Current time: 0.0
	Last Δt: 1.0e-7 (Min: 1.0e-7)
	Cycle count: 0 (Max: 1000000)
	CFL number: 0.2
	Number of zones: 1000
	Available fields: nzones, nedges, CFL, start_time, viscosity_coefficient, conductivity_coefficient, time, dt, cycles, min_dt, max_cycles, zone_edge, zone_center, zone_length, gamma, mass, density, velocity, pressure, intenergy, speedofsound, viscosity, energy_flux, momentum_rhs, energy_rhs</code></pre><p>The <code>init_state</code> variable is a <a href="../FunctionReference/#Euler1D.Simulation"><code>Simulation</code></a> type that holds information about the simulation. </p><div class="admonition is-info" id="Note-eb9c5442edc0aee7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-eb9c5442edc0aee7" title="Permalink"></a></header><div class="admonition-body"><p>The functions that describe the initial conditions are not called until <a href="../FunctionReference/#Euler1D.InitializeSimulation"><code>InitializeSimulation()</code></a> is called, at which time they are called at every point in the domain. For these reasons, it is good to be sure that the functions are not computationally heavy.</p></div></div><p>A common time to examine the Sod shock tube solution is <code>t=0.1</code>. The <a href="../FunctionReference/#Euler1D.AdvanceToTime"><code>AdvanceToTime()</code></a> function can be used to advance the simulation to this time:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; end_state = AdvanceToTime( init_state, 0.1; exact=true )</code></pre><p>where <code>0.1</code> is the time to advance to and the <code>exact=true</code> keyword tells the simulation to modify the final time step to stop as close as possible to the final time. If <code>exact=false</code> were supplied instead (or if the <code>exact</code> argument was omitted), the simulation would stop as soon as the current time is greater than the specified stopping time, but no modification of the timestep would be made and so the actual stopping time may differ from the specified stopping time. The size of the difference will depend on the timestep size.</p><div class="admonition is-success" id="Tip-6c917b4838af7d76"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-6c917b4838af7d76" title="Permalink"></a></header><div class="admonition-body"><p>This example wrote out the functions used for initial conditions in full for instructive purposes. However, there is no requirement that the functions be defined in this way. For example, for simple initial conditions, a function could be defined using <a href="https://docs.julialang.org/en/v1/manual/control-flow/">ternary operators</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_density( x ) = x &lt; 0.5 ? 1.0 : 0.125; # A function that varies in space</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_gamma( x ) = 1.4; # A function with a constant value</code></pre><p>or even using <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions">anonymous functions</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_density_function&quot;] = (x) -&gt; x &lt; 0.5 ? 1.0 : 0.125; # A function that varies in space</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_gamma_function&quot;] = (x) -&gt; 1.4; # A function with a constant value</code></pre><p>There is no requirement or advantage to using one method over any other. These are simply alternative ways of defining a function to describe the initial condition.</p></div></div><h2 id="Callbacks"><a class="docs-heading-anchor" href="#Callbacks">Callbacks</a><a id="Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks" title="Permalink"></a></h2><p>Often it may be desirable to have the simulation stop at certain points in order to perform some processing, modify simulation state, or write the current simulation state to a file, amongst other things. To facilitate this, Euler1D supports callbacks that can be called based on various criteria. In particular, Euler1D supports callbacks that can be called at a regular cadence based on the number of cycles (timesteps) that have occurred (<a href="../FunctionReference/#Euler1D.CycleCallback"><code>CycleCallback</code></a>), at a regular cadence based on an elapsed time (<a href="../FunctionReference/#Euler1D.TimeDeltaCallback"><code>TimeDeltaCallback</code></a>), or at a fixed list of (potentially irregularly-spaced) times (<a href="../FunctionReference/#Euler1D.TimeCallback"><code>TimeCallback</code></a>). </p><p>Setting up callbacks is straightforward. Considering the Sod Shock Tube example above, a structure containing information about callbacks can be created using <a href="../FunctionReference/#Euler1D.ConfigureSimulationCallbacks"><code>ConfigureSimulationCallbacks()</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; callbacks = ConfigureSimulationCallbacks(init_state)</code><code class="nohighlight hljs ansi" style="display:block;">SimulationCallback(CycleCallback[], TimeCallback[], TimeDeltaCallback[])</code></pre><p>From here, one can define functions that should be called at various defined points during the simulation. For illustrative purposes, we will define three callback functions here:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # A callback that will be called at a fixed list of times
       function MyTimeCallback( state::Simulation{T} ) where { T &lt;: AbstractFloat }
           println(&quot;In MyTimeCallback: Current time is $(state.time.x)&quot;)
       end;
       
       # A callback that will be called at a regular number of cycles</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function MyCycleCallback( state::Simulation{T} ) where { T &lt;: AbstractFloat }
           println(&quot;In MyCycleCallback: Current cycle is $(state.cycles.x)&quot;)
       end;
       
       # A callback that will be called at a regular temporal cadence</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function MyTimeDeltaCallback( state::Simulation{T} ) where { T &lt;: AbstractFloat }
           println(&quot;In MyTimeDeltaCallback: Current time is $(state.time.x)&quot;)
       end;</code></pre><p>These three functions can then be assigned to the <code>callbacks</code> structure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; RegisterTimeCallback!( callbacks, MyTimeCallback, Vector{Float64}([0.023, 0.067, 0.096]) ); # Register our time callback to run at t=0.023, 0.067, and 0.096</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; RegisterCycleCallback!( callbacks, MyCycleCallback, 250 ); # Register our cycle callback to run every 250 cycles</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; RegisterTimeDeltaCallback!( callbacks, MyTimeDeltaCallback, 0.03 ); # Register our time delta callback to run every 0.03 seconds
       
       # We can also register the same callback multiple times.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; RegisterTimeDeltaCallback!( callbacks, MyTimeDeltaCallback, 0.009, 0.05 ); # Let&#39;s register the time delta callback again, but starting at t=0.05 and with a increment of 0.009 seconds</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; RegisterCycleCallback!( callbacks, MyCycleCallback, 20, 1200 ); # We can also do the same thing with cycle-based callbacks. Here, we&#39;ll start at the 1200th cycle and print every 20 cycles</code></pre><p>We can then run the simulation and pass our callbacks as an argument:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; end_state = AdvanceToTime( init_state, 0.1; exact=true, callbacks=callbacks )</code><code class="nohighlight hljs ansi" style="display:block;">In MyCycleCallback: Current cycle is 1
In MyTimeDeltaCallback: Current time is 0.0001690308509456941
In MyCycleCallback: Current cycle is 251
In MyTimeCallback: Current time is 0.023042423974922847
In MyTimeDeltaCallback: Current time is 0.030013143574316222
In MyCycleCallback: Current cycle is 501
In MyTimeDeltaCallback: Current time is 0.05002420979482707
In MyCycleCallback: Current cycle is 751
In MyTimeDeltaCallback: Current time is 0.059033406153544604
In MyTimeDeltaCallback: Current time is 0.06004658746340014
In MyTimeCallback: Current time is 0.06705755438252575
In MyTimeDeltaCallback: Current time is 0.06806693391046942
In MyCycleCallback: Current cycle is 1001
In MyTimeDeltaCallback: Current time is 0.07706663455415017
In MyCycleCallback: Current cycle is 1200
In MyCycleCallback: Current cycle is 1220
In MyCycleCallback: Current cycle is 1240
In MyTimeDeltaCallback: Current time is 0.08603948328916335
In MyCycleCallback: Current cycle is 1251
In MyCycleCallback: Current cycle is 1260
In MyCycleCallback: Current cycle is 1280
In MyCycleCallback: Current cycle is 1300
In MyTimeDeltaCallback: Current time is 0.09004981092362775
In MyCycleCallback: Current cycle is 1320
In MyCycleCallback: Current cycle is 1340
In MyCycleCallback: Current cycle is 1360
In MyCycleCallback: Current cycle is 1380
In MyTimeDeltaCallback: Current time is 0.09505707066511998
In MyTimeCallback: Current time is 0.09605781431554984
In MyCycleCallback: Current cycle is 1400
In MyCycleCallback: Current cycle is 1420
In MyCycleCallback: Current cycle is 1440</code></pre><p>As you can see, the output from each of the callbacks is visible. Here, a rather simple example of just printing to the screen was used, but other options such as saving to disk, making plots, or other manipulations are possible.</p><h2 id="Plotting-Results"><a class="docs-heading-anchor" href="#Plotting-Results">Plotting Results</a><a id="Plotting-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Results" title="Permalink"></a></h2><p>This section outlines a few examples of how simulation data can be post-processed to visualize results or perform advanced processing.</p><div class="admonition is-info" id="Note-a5b69d3af2fa1149"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a5b69d3af2fa1149" title="Permalink"></a></header><div class="admonition-body"><p>There are numerous packages in the Julia ecosystem to handle plotting (e.g. <a href="https://docs.juliaplots.org/stable/">Plots.jl</a>, <a href="https://docs.makie.org/stable/">Makie.jl</a>), writing to disk (e.g. <a href="https://csv.juliadata.org/stable/">CSV.jl</a>, <a href="https://dataframes.juliadata.org/stable/">DataFrames.jl</a>, <a href="https://juliaio.github.io/HDF5.jl/stable/">HDF5.jl</a>), and any other data analysis routine that might be desired. The people developing these packages (and others like them) are immensely talented, and one would be well-advised to utilize their hard work if a package with suitable functionality exists.  For this reason, this package actively avoids making assumptions about what a user will want to do with the simulation data after the simulation is complete. This means that there is no built-in functionality to plot simulation data, write it to disk, or perform any other sort of postprocessing. Instead, all simulation outputs are simply elementary Julia types (e.g. <code>Vector{Float64}</code>), and can be manipulated using the usual built-in Julia methods, or by using any suitable package that provides the required functionality. </p></div></div><h3 id="Line-Plot"><a class="docs-heading-anchor" href="#Line-Plot">Line Plot</a><a id="Line-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Line-Plot" title="Permalink"></a></h3><p>The simplest case of post-processing data is to just plot profiles of the solution state at the final time in the simulation. Fortunately, all necessary fields can be obtained from the <code>Simulation</code> variable in the form of elementary Julia types. For example, to plot the profile of density from the simulation performed in <a href="#Sod-Shock-Tube">Sod Shock Tube</a> using the <a href="https://docs.juliaplots.org/stable/">Plots.jl</a> library, one can do</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot( end_state.zone_center, end_state.density );</code></pre><p><img src="../sod_density.svg" alt/></p><p>Similar plots can be made for other zone-centered quantities such as internal energy or pressure. </p><div class="admonition is-success" id="Tip-2de43a3ea66f7529"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-2de43a3ea66f7529" title="Permalink"></a></header><div class="admonition-body"><p>If plotting edge-centered quantities such as velocity, the <code>end_state.zone_edge</code> variable should be used for the spatial coordinate.</p></div></div><h3 id="X-T-diagrams"><a class="docs-heading-anchor" href="#X-T-diagrams">X-T diagrams</a><a id="X-T-diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#X-T-diagrams" title="Permalink"></a></h3><p>It is often useful to look at the evolution of the problem solution as a function of space and time rather than at just a single time instant. X-T (or space-time) diagrams are a useful way to perform this visualization. Gathering the data required to generate this type of plot is a little bit more complicated than the previous examples, however, so this section will walk through an example of how this might be done.</p><p>X-T diagrams can be made using quantities such as pressure or density, but <a href="https://en.wikipedia.org/wiki/Riemann_invariant">Riemann invariants</a> are a particularly powerful way to visualize the movement of waves within the domain. The Euler equations have positive and negative Riemann invariants, corresponding to rightwards- and leftwards-moving waves, respectively:</p><p class="math-container">\[J_\pm = u \pm \frac{2c}{\gamma - 1}\]</p><p>where <span>$J_\pm$</span> is the positive and negative Riemann invariant, <span>$c$</span> is the speed of sound, and <span>$\gamma$</span> is the ratio of specific heats. The value of the Riemann invariant is a constant along a wave, and so visualizing isocontours of <span>$J_\pm$</span> as a function of space and time will correspond to the various waves moving around the domain.</p><p>As the above equation makes clear, we will need to combine multiple aspects of the simulation solution in order to compute the Riemann invariants. Additionally, the <code>contour</code> function from <code>Plots.jl</code> that we will use to plot the result assumes that the data it is provided lies on a regular grid, while <code>Euler1D</code> simulations are on a Lagrangian mesh, so we will need to interpolate our data to a regular grid. Fortunately, we can use callbacks to perform both of these tasks as the simulation runs.</p><div class="admonition is-info" id="Note-394874946402dbd1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-394874946402dbd1" title="Permalink"></a></header><div class="admonition-body"><p>The need to interpolate the data onto a regular grid is a specific limitation of the <code>contour</code> function in <code>Plots.jl</code>. Other plotting routines may exist that do not have this requirement, in which case the interpolation step will not be required.</p></div></div><p>To start, the simulation can be set up identically to the Sod shock tube used in previous examples: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters = DefaultSimulationParameters();
       # We&#39;ll define our initialization functions using anonymous functions to keep things short</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_density_function&quot;] = (x) -&gt; x &lt; 0.5 ? 1.0 : 0.125;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_velocity_function&quot;] = (x) -&gt; 0.0;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_pressure_function&quot;] = (x) -&gt; x &lt; 0.5 ? 1.0 : 0.1;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulation_parameters[&quot;init_gamma_function&quot;] = (x) -&gt; 1.4;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_state = InitializeSimulation( simulation_parameters )</code></pre><p>Now we need to construct our callback to compute the Riemann invariants and interpolate it onto a regular grid. For this, we&#39;ll use the grid at <span>$t=0$</span> as our reference grid:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_positions = init_state.zone_center; # The x positions for plotting</code></pre><p>We will also need some arrays to store the resulting Riemann invariant values into. For this example, we&#39;ll run the simulation to <span>$t=1.0$</span>, while stopping to plot every 0.001 seconds:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sim_end = 1.0; # Run the simulation to t=1.0 seconds</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xt_dt = 0.001; # Stop to gather data for the X-T diagram every 0.001 seconds</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; N_callbacks = Int( div( sim_end, xt_dt ) ) + 1; # This is how many times the callback should be called. We add 1 to account for the first callback at t=0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xt_callback_count = 0; # How many times our plotting callback has been called. We&#39;ll use this to know where to save the Riemann invariant values for each callback</code></pre><p>Using this, we can construct the arrays we&#39;ll use the save the Riemann invariants:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_J₊ = zeros( N_callbacks, init_state.nzones ); # A matrix of the positive Riemann invariant values in every zone in the simulation</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_J₋ = zeros( N_callbacks, init_state.nzones ); # A matrix of the negative Riemann invariant values at every zone in the simulation</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_times = zeros( N_callbacks ); # The times at which the simulation data was saved.</code></pre><p>Now, finally, we can set up our actual callback routine</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Interpolations</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function xt_callback( state::Simulation{T} ) where { T &lt;: AbstractFloat }
           global plot_times[begin + xt_callback_count] = state.time.x # Record our current time
       
           # Now compute the Riemann invariants
           # For this we&#39;ll need to interpolate the velocities to zone centers, which we&#39;ll do with a simple average
           uₘ = 0.5 .* ( state.velocity[1:end-1] .+ state.velocity[2:end] )
       
           # Now compute the Riemann invariants
           J₊ = uₘ .+ ( 2.0 .* state.speedofsound ) ./ ( state.gamma .- 1.0 ) # Positive Riemann invariant
           J₋ = uₘ .- ( 2.0 .* state.speedofsound ) ./ ( state.gamma .- 1.0 ) # Negative Riemann invariant
       
           # Most contour plot functions assume data is on a cartesian grid
           # However, because the grid zones in the simulation are moving, we&#39;ll need to interpolate the data back onto a cartesian grid.
           # We can use Interpolations.jl for this
       
           # First the positive (right-moving) invariant
           J₊_interp = interpolate( ( state.zone_center, ), J₊, Gridded(Linear()) ) # Set up a linear interpolation of our data
           J₊_extrap = extrapolate( J₊_interp, Line() ) # Linearly extrapolate if needed.
           global plot_J₊[begin + xt_callback_count, :] = J₊_extrap( plot_positions ) # Interpolate the simulation data back onto the initial grid and add it to our matrix of data
       
           # Now the negative (left-moving) one
           J₋_interp = interpolate( ( state.zone_center, ), J₋, Gridded(Linear()) ) # Set up a linear interpolation of our data
           J₋_extrap = extrapolate( J₋_interp, Line() ) # Linearly extrapolate if needed
           global plot_J₋[begin + xt_callback_count, :] = J₋_extrap( plot_positions ) # Interpolate the simulation data back onto the initial grid and add it to our matrix of data
       
           # Finally, increment the counter that tracks the number of times this callback has been called
           global xt_callback_count += 1
       end;</code></pre><p>Finally, we can add this callback to our simulation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; callbacks = ConfigureSimulationCallbacks(init_state);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; RegisterTimeDeltaCallback!( callbacks, xt_callback, xt_dt ); # Register our X-T plotting callback</code></pre><p>And now, we can run the simulation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; end_state = AdvanceToTime( init_state, sim_end; exact=true, callbacks=callbacks )</code></pre><p>With the simulation complete, we can now plot our X-T diagram. First, compute the minimum and maximum Riemann invariant values, as this will help us set the limits for our plot:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; minJ = min( minimum( plot_J₊ ), minimum( plot_J₋ ) );</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; maxJ = max( maximum( plot_J₊ ), maximum( plot_J₊ ) );</code></pre><p>These values can then be used to create the contour plot</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = contour( plot_positions, plot_times, plot_J₊; c=:black, levels=minJ:0.2:maxJ, cbar=false ); # Positive invariants</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; contour!( p, plot_positions, plot_times, plot_J₋; c=:black, levels=minJ:0.2:maxJ ); # Negative invariants</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; savefig( p, &quot;sod_xt.svg&quot; );</code></pre><p>These lines are responsible for actually creating the contour plot. The first line plots the positive (rightwards-moving) Riemann invariants, and the second line adds a plot for the negative (leftwards-moving) Riemann invariants. The optional arguments are <code>c</code>, which sets the line color, <code>levels</code>, which sets the contour levels to plot, and <code>cbar</code>, which tells the plotting routine not to plot a colorbar as it isn&#39;t useful in these contexts. Finally, <code>savefig</code> saves the plot to a file called <code>sod_xt.svg</code>. Running these lines gives us our X-T diagram:</p><p><img src="../sod_xt.svg" alt/></p><p>And, voila! You can see the leftwards moving expansion wave and the rightwards moving shock and contact surface. Reflections off of the end walls are also visible, as are interactions between different waves. </p><div class="admonition is-info" id="Note-4b6a0f2ac0571ca6"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4b6a0f2ac0571ca6" title="Permalink"></a></header><div class="admonition-body"><p>The <code>levels</code> argument, particularly the step size of <code>0.2</code>, was tuned to produce a good looking plot for this case. You will probably need to adjust this for other configurations.</p></div></div><div class="admonition is-success" id="Tip-b192396bc6d32fa0"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-b192396bc6d32fa0" title="Permalink"></a></header><div class="admonition-body"><p>The plot colors were set to black as this makes a uniform looking plot. However, you might try plotting the two with different colors (say, <code>c=:red</code> in one plot) as this will show how the positive and negative Riemann invariants correspond to left- and right-moving waves.</p></div></div><div class="admonition is-success" id="Tip-761cc4c879fe1889"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-761cc4c879fe1889" title="Permalink"></a></header><div class="admonition-body"><p>You might notice that things like the material interface look a little wider than might be expected. Try playing around with the <code>artificial_viscosity_coefficient</code> and <code>artificial_conductivity_coefficient</code> values to see what effect these parameters have.</p></div></div><h2 id="Modifying-Problem-State"><a class="docs-heading-anchor" href="#Modifying-Problem-State">Modifying Problem State</a><a id="Modifying-Problem-State-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-Problem-State" title="Permalink"></a></h2><p>There may be cases where it is desirable to stop and modify the problem state part way through a simulation. For example, to add another shock wave. This can be done using the <a href="../FunctionReference/#Euler1D.UpdateSimulationState!"><code>UpdateSimulationState!()</code></a> function. This function takes four arguments that are <code>Function</code>s describing the new problem density, velocity, pressure, and ratio of specific heats. However, in this case the functions have a slightly different signature:</p><pre><code class="language-julia hljs">function my_new_state( x, oldValue )
    ...
end</code></pre><p>Notice that there is now an <code>oldValue</code> argument. This will hold the current value of the variable at the position <code>x</code>. If you don&#39;t want to modify anything, you can just return <code>oldValue</code> from this function.</p><p>As a trivial example, let&#39;s say we want to modify the example from the <a href="#Line-Plot">Line Plot</a> section to add a sinusoidal profile to the existing density, set the velocity to zero, and leave everything else untouched. Our functions might look like</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_density( x, oldValue )
           return 0.05 * sin( 20 * pi * x ) + 0.05 + oldValue # Need to add a value to make sure density doesn&#39;t go to zero
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_velocity( x, oldValue )
           return 0.0
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_pressure( x, oldValue )
           return oldValue
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function update_gamma( x, oldValue )
           return oldValue
       end;</code></pre><p>With these functions we can now update the problem state:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; UpdateSimulationState!( end_state, update_gamma, update_density, update_velocity, update_pressure )</code></pre><p>and if we plot density again, we&#39;ll see the density field has been updated:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot( end_state.zone_center, end_state.density );</code></pre><p><img src="../sod_density_updated.svg" alt/></p><p>and the velocity field is now zero everywhere:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot( end_state.zone_edge, end_state.velocity );</code></pre><p><img src="../sod_velocity_updated.svg" alt/></p><p>Functions like these could, for example, be set up to run within a <a href="../FunctionReference/#Euler1D.TimeCallback"><code>TimeCallback</code></a> in order to update the problem state at a known time in order to, for example, add another shock wave.</p><div class="admonition is-category-caution" id="Caution-f1b1ab08e7848b82"><header class="admonition-header">Caution<a class="admonition-anchor" href="#Caution-f1b1ab08e7848b82" title="Permalink"></a></header><div class="admonition-body"><p>The functions to update the simulation state in this example were chosen to be illustrative, and it&#39;s likely the simulation would be unstable following this change. Care should be taken to ensure the updated state makes sense.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Euler1D</a><a class="docs-footer-nextpage" href="../Methodology/">Methodology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 2 January 2026 01:59">Friday 2 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
